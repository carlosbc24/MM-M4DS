[comment encoding = UTF-8 /]
[**
 * The documentation of the module generate.
 */]
[module generate('https://www.example.org/contract', 'https://www.example.org/workflow', 'https://www.example.org/contractDef')]


[template public generateCallContract(aContract : Contract, dp : DataProcessing)]
[if (aContract._in->exists(df | df.oclIsTypeOf(DataField)))]															[comment OPEN checks that the contract data input is a DataField/]
	[for (odf : Object | aContract._in->select(odf | odf.oclIsTypeOf(DataField)))]
    	[let df : DataField = odf.oclAsType(DataField)]
			[if (df.oclIsTypeOf(Continuous) and df.dataField.oclAsType(Continuous).numDecimals <> null)]
			[/if]
[comment]The contracts below are of type FieldRange[/comment]
			[if (aContract.oclIsTypeOf(FieldRange))]																	[comment OPEN checks that the contract is of type FieldRange (usually a Pre or Post condition)/]
				[let fr : FieldRange = aContract.oclAsType(FieldRange)]													[comment OPEN assigns the variable to be of type FieldRange/]
field_list_[fr.fieldRangeDef.name/]=['['/][for (field : Field | fr.field) separator(', ')]'[field.dataField.displayName/]'[/for][']'/]
if contract_pre_post.check_field_range(fields=field_list_[fr.fieldRangeDef.name/],
							data_dictionary=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
							belong_op=Belong([if (fr.belongOp=BelongOp::BELONG)]0[else]1[/if]), origin_function="[dp.origin_function/]"):
	print('[fr.fieldRangeDef.type/] [dp.origin_function/]_([for (field : Field | fr.field) separator(', ')][field.dataField.displayName/][/for]) VALIDATED')
else:
	print('[fr.fieldRangeDef.type/] [dp.origin_function/]_([for (field : Field | fr.field) separator(', ')][field.dataField.displayName/][/for]) NOT VALIDATED')
				[/let]																									[comment CLOSE assigns the variable to be of type FieldRange/]
			[/if]																										[comment CLOSE checks that the contract is of type FieldRange (usually a Pre or Post condition)/]
[comment]The contracts below are of type ValueRange[/comment]
			[if (aContract.oclIsTypeOf(ValueRange))]																	[comment OPEN checks that the contract is of type ValueRange (usually a Pre or Post condition)/]
				[let vr : ValueRange = aContract.oclAsType(ValueRange)]													[comment OPEN assigns the variable to be of type ValueRange/]
					[for (v : RowValue | vr.value)]																		[comment OPEN traverse all the values in the contract to know which pre-post contract call/]
						[if (v.oclIsTypeOf(FixValue))]																	[comment OPEN checks that the value to check is a FixValue/]
							[let fv : FixValue = v.oclAsType(FixValue)]													[comment OPEN assigns the variable to be of type FixValue/]
								[if (v.quantity <> null)]																[comment OPEN checks that the quantity is not null (there is an operator and a quant)/]
									[if(v.quantity.oclIsTypeOf(AbsoluteValue))]											[comment OPEN checks that the quantity is of type Absolute/]
										[let av : AbsoluteValue = v.quantity.oclAsType(AbsoluteValue)]					[comment OPEN assigns the variable to be of type Absolute/]
if contract_pre_post.check_fix_value_range([if (fv.dataType=DataType::String or fv.dataType=DataType::Time or fv.dataType=DataType::DateTime)]value='[fv.value/]'[else]value=[fv.value/][/if], is_substring=[if (fv.subStr=true)]True[elseif (fv.subStr=false)]False[/if], data_dictionary=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df, belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), field='[df.dataField.displayName/]',
								quant_abs=[av.value/], quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), origin_function="[dp.origin_function/]"):
	print('[vr.valueRangeDef.type/] [dp.origin_function/]([df.dataField.displayName/]) FixValue:[fv.value/] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [dp.origin_function/]([df.dataField.displayName/]) FixValue:[fv.value/] NOT VALIDATED')
										[/let]																			[comment CLOSE assigns the variable to be of type Absolute/]
									[elseif (v.quantity.oclIsTypeOf(Percent))]											[comment OPEN checks that the quantity is of type Percent/]
										[let per : Percent = v.quantity.oclAsType(Percent)]								[comment OPEN assigns the variable to be of type Percent/]
if contract_pre_post.check_fix_value_range([if (fv.dataType=DataType::String or fv.dataType=DataType::Time or fv.dataType=DataType::DateTime)]value='[fv.value/]'[else]value=[fv.value/][/if], is_substring=[if (fv.subStr=true)]True[elseif (fv.subStr=false)]False[/if], data_dictionary=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df, belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), field='[df.dataField.displayName/]',
								quant_rel=[per.percent/], quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), origin_function="[dp.origin_function/]"):
	print('[vr.valueRangeDef.type/] [dp.origin_function/]([df.dataField.displayName/]) FixValue:[fv.value/] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [dp.origin_function/]([df.dataField.displayName/]) FixValue:[fv.value/] NOT VALIDATED')
										[/let]																			[comment CLOSE assigns the variable to be of type Percent/]
									[/if]																				[comment CLOSE checks that the quantity is of type Absolute or Percent/]
								[else]																					[comment OPEN checks that the quantity not null (there are not operators or quants)/]
if contract_pre_post.check_fix_value_range([if (fv.dataType=DataType::String or fv.dataType=DataType::Time or fv.dataType=DataType::DateTime)]value='[fv.value/]'[else]value=[fv.value/][/if], is_substring=[if (fv.subStr=true)]True[elseif (fv.subStr=false)]False[/if], data_dictionary=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df, belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), field='[df.dataField.displayName/]',
								quant_abs=None, quant_rel=None, quant_op=None, origin_function="[dp.origin_function/]"):
	print('[vr.valueRangeDef.type/] [dp.origin_function/]([df.dataField.displayName/]) FixValue:[fv.value/] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [dp.origin_function/]([df.dataField.displayName/]) FixValue:[fv.value/] NOT VALIDATED')
								[/if]																					[comment CLOSE checks that the quantity is not null (there are not operators or quants)/]
							[/let]																						[comment CLOSE assigns the variable to be of type FixValue/]
						[elseif (v.oclIsTypeOf(Interval))]																[comment OPEN checks that the variable is of type Interval/]
							[let inter : Interval = v.oclAsType(Interval)]												[comment OPEN assigns the variable to be of type Interval/]
if contract_pre_post.check_interval_range_float(left_margin=[inter.leftMargin/], right_margin=[inter.rightMargin/], data_dictionary=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
                                	closure_type=Closure([if (inter.closureType=ClosureType::openOpen)]0[elseif (inter.closureType=ClosureType::openClosed)]1[elseif (inter.closureType=ClosureType::closedOpen)]2[elseif (inter.closureType=ClosureType::closedClosed)]3[/if]), belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), field='[df.dataField.displayName/]', origin_function="[dp.origin_function/]"):
	print('[vr.valueRangeDef.type/] [dp.origin_function/]([df.dataField.displayName/]) Interval:[if (inter.closureType=ClosureType::openOpen or inter.closureType=ClosureType::openClosed)]([elseif (inter.closureType=ClosureType::closedOpen or inter.closureType=ClosureType::closedClosed)]['['/][/if][inter.leftMargin/], [inter.rightMargin/][if (inter.closureType=ClosureType::openOpen or inter.closureType=ClosureType::closedOpen)])[elseif (inter.closureType=ClosureType::closedClosed or inter.closureType=ClosureType::openClosed)][']'/][/if] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [dp.origin_function/]([df.dataField.displayName/]) Interval:[if (inter.closureType=ClosureType::openOpen or inter.closureType=ClosureType::openClosed)]([elseif (inter.closureType=ClosureType::closedOpen or inter.closureType=ClosureType::closedClosed)]['['/][/if][inter.leftMargin/], [inter.rightMargin/][if (inter.closureType=ClosureType::openOpen or inter.closureType=ClosureType::closedOpen)])[elseif (inter.closureType=ClosureType::closedClosed or inter.closureType=ClosureType::openClosed)][']'/][/if] NOT VALIDATED')
							[/let]																						[comment CLOSE assigns the variable to be of type Interval/]
						[elseif (v.oclIsTypeOf(CastType))]																[comment OPEN checks that the variable is of type CastType/]
							[let castType : CastType = v.oclAsType(CastType)]												[comment OPEN assigns the variable to be of type CastType/]
if contract_pre_post.check_field_type(data_dictionary=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
                                	  field='[df.dataField.displayName/]', field_type=[if (castType.type=DataType::String)]DataType(0)[elseif (castType.type=DataType::Time)]DataType(1)[elseif (castType.type=DataType::Integer)]DataType(2)[elseif (castType.type=DataType::DateTime)]DataType(3)[elseif (castType.type=DataType::Boolean)]DataType(4)[elseif (castType.type=DataType::Double)]DataType(5)[elseif (castType.type=DataType::Float)]DataType(6)[else]None)[/if], origin_function="[dp.origin_function/]"):
	print('[vr.valueRangeDef.type/] [dp.origin_function/]([df.dataField.displayName/]) Type:[if (castType.type=DataType::String)]String[elseif (castType.type=DataType::Time)]Time[elseif (castType.type=DataType::Integer)]Integer[elseif (castType.type=DataType::DateTime)]DateTime[elseif (castType.type=DataType::Boolean)]Boolean[elseif (castType.type=DataType::Double)]Double[elseif (castType.type=DataType::Float)]Float[else]None)[/if] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [dp.origin_function/]([df.dataField.displayName/]) Type:[if (castType.type=DataType::String)]String[elseif (castType.type=DataType::Time)]Time[elseif (castType.type=DataType::Integer)]Integer[elseif (castType.type=DataType::DateTime)]DateTime[elseif (castType.type=DataType::Boolean)]Boolean[elseif (castType.type=DataType::Double)]Double[elseif (castType.type=DataType::Float)]Float[else]None)[/if] NOT VALIDATED')
							[/let]																						[comment CLOSE assigns the variable to be of type CastType/]
						[elseif (v.oclIsTypeOf(SpecialValue))]															[comment OPEN checks that the variable is of type SpecialValue/]
							[let sv : SpecialValue = v.oclAsType(SpecialValue)]											[comment OPEN assigns the variable to be of type SpecialValue/]
								[if (v.quantity <> null)]																[comment OPEN checks that the quantity is not null (there are not operators or quants)/]
									[if (sv.specialType=SpecialType::MISSING)]											[comment OPEN checks that the SpecialType is MISSING/]
missing_values_[vr.valueRangeDef.name/]=['['/][for (mv : ValueField | df.dataField.missingValues->asOrderedSet()) separator(', ')][if (df.dataField.dataType=DataType::String or df.dataField.dataType=DataType::Time or df.dataField.dataType=DataType::DateTime)]'[mv.value/]'[else][mv.value/][/if][/for][']'/]
										[if(v.quantity.oclIsTypeOf(AbsoluteValue))]										[comment OPEN checks that the quantity is Absolute/]
											[let av : AbsoluteValue = v.quantity.oclAsType(AbsoluteValue)]				[comment OPEN assigns the variable to be of type AbsoluteValue/]
if contract_pre_post.check_missing_range(belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), data_dictionary=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df, field='[df.dataField.displayName/]', 
								missing_values=missing_values_[vr.valueRangeDef.name/],
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_abs=[av.value/], origin_function="[dp.origin_function/]"):
	print('[vr.valueRangeDef.type/] [dp.origin_function/]([df.dataField.displayName/]) MissingValues:['['/][for (mv : ValueField | df.dataField.missingValues->asOrderedSet()) separator(', ')][mv.value/][/for][']'/] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [dp.origin_function/]([df.dataField.displayName/]) MissingValues:['['/][for (mv : ValueField | df.dataField.missingValues->asOrderedSet()) separator(', ')][mv.value/][/for][']'/] NOT VALIDATED')
											[/let]																		[comment CLOSE assigns the variable to be of type AbsoluteValue/]
										[elseif (v.quantity.oclIsTypeOf(Percent))]										[comment OPEN checks that the quantity is Percent/]
											[let per : Percent = v.quantity.oclAsType(Percent)]							[comment OPEN assigns the variable to be of type Percent/]
if contract_pre_post.check_missing_range(belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), data_dictionary=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df, field='[df.dataField.displayName/]', 
								missing_values=missing_values_[vr.valueRangeDef.name/],
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_rel=[per.percent/]/100, origin_function="[dp.origin_function/]"):
	print('[vr.valueRangeDef.type/] [dp.origin_function/]([df.dataField.displayName/]) MissingValues:['['/][for (mv : ValueField | df.dataField.missingValues->asOrderedSet()) separator(', ')][mv.value/][/for][']'/] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [dp.origin_function/]([df.dataField.displayName/]) MissingValues:['['/][for (mv : ValueField | df.dataField.missingValues->asOrderedSet()) separator(', ')][mv.value/][/for][']'/] NOT VALIDATED')
											[/let]																		[comment CLOSE assigns the variable to be of type Percent/]
										[/if]																			[comment CLOSE checks that the quantity is AbsoluteValue or Percent/]
									[elseif (sv.specialType=SpecialType::INVALID)]										[comment OPEN checks that the SpecialType is INVALID/]
invalid_values_[vr.valueRangeDef.name/]=['['/][for (mv : ValueField | df.dataField.invalidValues->asOrderedSet()) separator(', ')][mv.value/][/for][']'/]
										[if(v.quantity.oclIsTypeOf(AbsoluteValue))]										[comment OPEN checks that the quantity is AbsoluteValue/]
											[let av : AbsoluteValue = v.quantity.oclAsType(AbsoluteValue)]				[comment OPEN assigns the variable to be of type AbsoluteValue/]
if contract_pre_post.check_invalid_values(belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), data_dictionary=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df, field='[df.dataField.displayName/]', 
								invalid_values=invalid_values_[vr.valueRangeDef.name/],
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_abs=[av.value/], origin_function="[dp.origin_function/]"):
	print('[vr.valueRangeDef.type/] [dp.origin_function/]([df.dataField.displayName/]) InvalidValues:['['/][for (mv : ValueField | df.dataField.invalidValues->asOrderedSet()) separator(', ')][mv.value/][/for][']'/] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [dp.origin_function/]([df.dataField.displayName/]) InvalidValues:['['/][for (mv : ValueField | df.dataField.invalidValues->asOrderedSet()) separator(', ')][mv.value/][/for][']'/] NOT VALIDATED')
											[/let]																		[comment CLOSE assigns the variable to be of type AbsoluteValue/]
										[elseif (v.quantity.oclIsTypeOf(Percent))]										[comment OPEN checks that the quantity is Percent/]
											[let per : Percent = v.quantity.oclAsType(Percent)]							[comment OPEN assigns the variable to be of type Percent/]
if contract_pre_post.check_invalid_values(belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), data_dictionary=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df, field='[df.dataField.displayName/]', 
								invalid_values=invalid_values_[vr.valueRangeDef.name/],
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_rel=[per.percent/]/100, origin_function="[dp.origin_function/]"):
	print('[vr.valueRangeDef.type/] [dp.origin_function/]([df.dataField.displayName/]) InvalidValues:['['/][for (mv : ValueField | df.dataField.invalidValues->asOrderedSet()) separator(', ')][mv.value/][/for][']'/] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [dp.origin_function/]([df.dataField.displayName/]) InvalidValues:['['/][for (mv : ValueField | df.dataField.invalidValues->asOrderedSet()) separator(', ')][mv.value/][/for][']'/] NOT VALIDATED')
											[/let]																		[comment CLOSE assigns the variable to be of type AbsoluteValue/]
										[/if]																			[comment CLOSE checks that the quantity is AbsoluteValue or Percent/]
									[elseif (sv.specialType=SpecialType::OUTLIER)]										[comment OPEN checks that the SpecialType is OUTLIER/]
										[if(v.quantity.oclIsTypeOf(AbsoluteValue))]										[comment OPEN checks that the quantity is AbsoluteValue/]
											[let av : AbsoluteValue = v.quantity.oclAsType(AbsoluteValue)]				[comment OPEN assigns the variable to be of type AbsoluteValue/]
if contract_pre_post.check_outliers(belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), data_dictionary=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df, field='[df.dataField.displayName/]', 
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_abs=[av.value/], origin_function="[dp.origin_function/]"):
	print('[vr.valueRangeDef.type/] [dp.origin_function/]([df.dataField.displayName/]) VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [dp.origin_function/]([df.dataField.displayName/]) NOT VALIDATED')
											[/let]																		[comment CLOSE assigns the variable to be of type AbsoluteValue/]
										[elseif (v.quantity.oclIsTypeOf(Percent))]										[comment OPEN checks that the quantity is Percent/]
											[let per : Percent = v.quantity.oclAsType(Percent)]							[comment OPEN assigns the variable to be of type Percent/]
if contract_pre_post.check_outliers(belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), data_dictionary=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df, field='[df.dataField.displayName/]', 
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_rel=[per.percent/]/100, origin_function="[dp.origin_function/]"):
	print('[vr.valueRangeDef.type/] [dp.origin_function/]([df.dataField.displayName/]) VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [dp.origin_function/]([df.dataField.displayName/]) NOT VALIDATED')
											[/let]																		[comment CLOSE assigns the variable to be of type Percent/]
										[/if]																			[comment CLOSE checks that the quantity is AbsoluteValue or Percent/]
									[/if]																				[comment CLOSE checks that the SpecialType is MISSING, INVALID or OUTLIER/]
								[elseif (v.quantity = null)]															[comment OPEN checks that the quantity is null/]
									[if (sv.specialType=SpecialType::MISSING)]											[comment OPEN checks that the SpecialType is MISSING/]
missing_values_[vr.valueRangeDef.name/]=['['/][for (mv : ValueField | df.dataField.missingValues->asOrderedSet()) separator(', ')][if (df.dataField.dataType=DataType::String or df.dataField.dataType=DataType::Time or df.dataField.dataType=DataType::DateTime)]'[mv.value/]'[else][mv.value/][/if][/for][']'/]
if contract_pre_post.check_missing_range(belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), data_dictionary=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df, field='[df.dataField.displayName/]', 
								missing_values=missing_values_[vr.valueRangeDef.name/],
								quant_abs=None, quant_rel=None, quant_op=None, origin_function="[dp.origin_function/]"):
	print('[vr.valueRangeDef.type/] [dp.origin_function/]([df.dataField.displayName/]) MissingValues:['['/][for (mv : ValueField | df.dataField.missingValues->asOrderedSet()) separator(', ')][mv.value/][/for][']'/] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [dp.origin_function/]([df.dataField.displayName/]) MissingValues:['['/][for (mv : ValueField | df.dataField.missingValues->asOrderedSet()) separator(', ')][mv.value/][/for][']'/] NOT VALIDATED')
									[elseif (sv.specialType=SpecialType::INVALID)]										[comment OPEN checks that the SpecialType is INVALID/]
invalid_values_[vr.valueRangeDef.name/]=['['/][for (mv : ValueField | df.dataField.invalidValues->asOrderedSet()) separator(', ')][mv.value/][/for][']'/]
if contract_pre_post.check_invalid_values(belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), data_dictionary=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df, field='[df.dataField.displayName/]', 
								invalid_values=invalid_values_[vr.valueRangeDef.name/],
								quant_abs=None, quant_rel=None, quant_op=None, origin_function="[dp.origin_function/]"):
	print('[vr.valueRangeDef.type/] [dp.origin_function/]([df.dataField.displayName/]) InvalidValues:['['/][for (mv : ValueField | df.dataField.invalidValues->asOrderedSet()) separator(', ')][mv.value/][/for][']'/] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [dp.origin_function/]([df.dataField.displayName/]) InvalidValues:['['/][for (mv : ValueField | df.dataField.invalidValues->asOrderedSet()) separator(', ')][mv.value/][/for][']'/] NOT VALIDATED')
									[elseif (sv.specialType=SpecialType::OUTLIER)]										[comment OPEN checks that the SpecialType is OUTLIER/]
if contract_pre_post.check_outliers(belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), data_dictionary=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df, field='[df.dataField.displayName/]', 
								quant_abs=None, quant_rel=None, quant_op=None, origin_function="[dp.origin_function/]"):
	print('[vr.valueRangeDef.type/] [dp.origin_function/]([df.dataField.displayName/]) VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [dp.origin_function/]([df.dataField.displayName/]) NOT VALIDATED')
									[/if]																				[comment CLOSE checks that the SpecialType is MISSING, INVALID or OUTLIER/]
								[/if]																					[comment CLOSE checks that the quantity is not null (there are not operators or quants)/]
							[/let]																						[comment CLOSE assigns the variable to be of type SpecialValue/]
						[/if]																							[comment CLOSE checks that the quantity is null or not null/]
					[/for]																								[comment CLOSE traverse all the values in the contract to know which pre-post contract call/]
				[/let]																									[comment CLOSE assigns the variable to be of type ValueRange/]
			[/if]																										[comment CLOSE aContract.oclIsTypeOf()/]
		[/let]
	[/for]
	[if (aContract.oclIsTypeOf(Condition))]																				[comment OPEN Contracts of type Condition (Invariants)/]
[generateCallConditionContract(aContract)/]
	[/if]
[/if]
[if (aContract._in->exists(dd | dd.oclIsTypeOf(DataDictionary)))]														[comment OPEN assigns the variable to be of type DataDictionary/]
[generateCallDataDicContract(aContract)/]
[/if]																													[comment CLOSE assigns the variable to be of type DataField or DataDictionary/]
[/template]


[template public generateCallDataDicContract(aContract : Contract)] 		[comment IT IS THE SAME AS generateCallContract(aContract : Contract) but the data input to the contract is a DataDictionary instead of a DataField/]
[for (odd : Object | aContract._in->select(odd | odd.oclIsTypeOf(DataDictionary)))]
	[let dd : DataDictionary = odd.oclAsType(DataDictionary)]																[comment OPEN assigns the input in the contract to be of type DataDictionary/]
[comment]The contracts below are of type FieldRange[/comment]
		[if (aContract.oclIsTypeOf(FieldRange))]																			[comment OPEN checks that the contract is of type FieldRange/]
			[let fr : FieldRange = aContract.oclAsType(FieldRange)]															[comment OPEN assigns the variable to be of type FieldRange/]
				[if (fr.fieldRangeDef.type=ContractType::PRECONDITION)]															[comment OPEN checks if it is a Precondition/]					
					[for (dd_in : Workflow::DataDictionary | aContract.eContainer(Workflow::DataProcessing).inputPort)]		[comment OPEN traverse all the input DataDictionaries/]
field_list_[fr.fieldRangeDef.name/]=['['/][for (field : Field | fr.field) separator(', ')]'[field.dataField.displayName/]'[/for][']'/]
						[for (field : Field | fr.field)]	
							[if (field.dataField.oclIsTypeOf(Continuous))]
							[/if]
						[/for]
if contract_pre_post.check_field_range(fields=field_list_[fr.fieldRangeDef.name/],
							data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df,
							belong_op=Belong([if (fr.belongOp=BelongOp::BELONG)]0[else]1[/if]), origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[fr.fieldRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([for (field : Field | fr.field) separator(', ')][field.dataField.displayName/][/for]) VALIDATED')
else:
	print('[fr.fieldRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([for (field : Field | fr.field) separator(', ')][field.dataField.displayName/][/for]) NOT VALIDATED')
					[/for]																									[comment CLOSE traverse all the input DataDictionaries/]
				[elseif (fr.fieldRangeDef.type=ContractType::POSTCONDITION)]														[comment OPEN checks if it is a Postcondition/]
					[for (dd_out : Workflow::DataDictionary | aContract.eContainer(Workflow::DataProcessing).outputPort)]	[comment OPEN traverse all the output DataDictionaries/]
field_list_[fr.fieldRangeDef.name/]=['['/][for (field : Field | fr.field) separator(', ')]'[field.dataField.displayName/]'[/for][']'/]
if contract_pre_post.check_field_range(fields=field_list_[fr.fieldRangeDef.name/],
							data_dictionary=[dd_out.name.replaceAll('[(),-/\\s]+', '_')/]_df,
							belong_op=Belong([if (fr.belongOp=BelongOp::BELONG)]0[else]1[/if]), origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[fr.fieldRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([for (field : Field | fr.field) separator(', ')][field.dataField.displayName/][/for]) VALIDATED')
else:
	print('[fr.fieldRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([for (field : Field | fr.field) separator(', ')][field.dataField.displayName/][/for]) NOT VALIDATED')
					[/for]																									[comment CLOSE traverse all the output DataDictionaries/]
				[/if]																										[comment CLOSE checks if it is a Precondition or a Postcondition/]
			[/let]																											[comment CLOSE assigns the variable to be of type FieldRange/]
		[/if]																												[comment CLOSE checks that the contract is of type FieldRange/]
		[if (aContract.oclIsTypeOf(ValueRange))]																			[comment OPEN checks if the contract is a ValueRange/]
			[let vr : ValueRange = aContract.oclAsType(ValueRange)]															[comment OPEN assigns the contract to be a ValueRange/]
				[if (vr.valueRangeDef.type=ContractType::PRECONDITION)]															[comment OPEN checks if it is a Precondition/]
					[for (dd_in : Workflow::DataDictionary | aContract.eContainer(Workflow::DataProcessing).inputPort)]		[comment OPEN traverse all the input DataDictionaries/]
						[for (v : RowValue | vr.value)]																		[comment OPEN traverse all the parameters/]
							[if (v.oclIsTypeOf(FixValue))]																	[comment OPEN checks if the parameter is a FixValue/]
								[let fv : FixValue = v.oclAsType(FixValue)]													[comment OPEN assigns the parameter to be a FixValue/]
									[if (v.quantity <> null)]																[comment OPEN checks if the quantity is not null/]
										[if(v.quantity.oclIsTypeOf(AbsoluteValue))]											[comment OPEN checks if the quantity is an AbsoluteValue/]
											[let av : AbsoluteValue = v.quantity.oclAsType(AbsoluteValue)]					[comment OPEN assigns the variable to be an AbsoluteValue/]
if contract_pre_post.check_fix_value_range([if (fv.dataType=DataType::String or fv.dataType=DataType::Time or fv.dataType=DataType::DateTime)]value='[fv.value/]'[else]value=[fv.value/][/if], is_substring=[if (fv.subStr=true)]True[elseif (fv.subStr=false)]False[/if], data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df, belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), field=None,
								quant_abs=[av.value/], quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) FixValue:[fv.value/] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) FixValue:[fv.value/] NOT VALIDATED')
											[/let]																			[comment CLOSE assigns the variable to be an AbsoluteValue/]
										[elseif (v.quantity.oclIsTypeOf(Percent))]											[comment OPEN checks if the quantity is a Percent/]
											[let per : Percent = v.quantity.oclAsType(Percent)]								[comment OPEN assigns the variable to be a Percent/]
if contract_pre_post.check_fix_value_range([if (fv.dataType=DataType::String or fv.dataType=DataType::Time or fv.dataType=DataType::DateTime)]value='[fv.value/]'[else]value=[fv.value/][/if], is_substring=[if (fv.subStr=true)]True[elseif (fv.subStr=false)]False[/if], data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df, belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), field=None,
								quant_rel=[per.percent/], quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) FixValue:[fv.value/] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) FixValue:[fv.value/] NOT VALIDATED')
											[/let]																			[comment CLOSE assigns the variable to be a Percent/]
										[/if]																				[comment CLOSE checks if the quantity is an AbsoluteValue or a Percent/]
									[else]																					[comment OPEN checks if the quantity is null/]
if contract_pre_post.check_fix_value_range([if (fv.dataType=DataType::String or fv.dataType=DataType::Time or fv.dataType=DataType::DateTime)]value='[fv.value/]'[else]value=[fv.value/][/if], is_substring=[if (fv.subStr=true)]True[elseif (fv.subStr=false)]False[/if], data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df, belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), field=None,
								quant_abs=None, quant_rel=None, quant_op=None, origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) FixValue:[fv.value/] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) FixValue:[fv.value/] NOT VALIDATED')
									[/if]																					[comment CLOSE checks if the quantity is null/]
								[/let]																						[comment CLOSE assigns the parameter to be a FixValue/]
							[elseif (v.oclIsTypeOf(Interval))]																[comment OPEN checks if the parameter is an interval/]
								[let inter : Interval = v.oclAsType(Interval)]												[comment OPEN assigns the variable to be an interval/]
if contract_pre_post.check_interval_range_float(left_margin=[inter.leftMargin/], right_margin=[inter.rightMargin/], data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df,
                               closure_type=Closure([if (inter.closureType=ClosureType::openOpen)]0[elseif (inter.closureType=ClosureType::openClosed)]1[elseif (inter.closureType=ClosureType::closedOpen)]2[elseif (inter.closureType=ClosureType::closedClosed)]3[/if]), belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), field_in=None, field_out=None, origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) Interval:[if (inter.closureType=ClosureType::openOpen or inter.closureType=ClosureType::openClosed)]([elseif (inter.closureType=ClosureType::closedOpen or inter.closureType=ClosureType::closedClosed)]['['/][/if][inter.leftMargin/], [inter.rightMargin/][if (inter.closureType=ClosureType::openOpen or inter.closureType=ClosureType::closedOpen)])[elseif (inter.closureType=ClosureType::closedClosed or inter.closureType=ClosureType::openClosed)][']'/][/if] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) Interval:[if (inter.closureType=ClosureType::openOpen or inter.closureType=ClosureType::openClosed)]([elseif (inter.closureType=ClosureType::closedOpen or inter.closureType=ClosureType::closedClosed)]['['/][/if][inter.leftMargin/], [inter.rightMargin/][if (inter.closureType=ClosureType::openOpen or inter.closureType=ClosureType::closedOpen)])[elseif (inter.closureType=ClosureType::closedClosed or inter.closureType=ClosureType::openClosed)][']'/][/if] NOT VALIDATED')
								[/let]																						[comment CLOSE assigns the variable to be an interval/]
							[elseif (v.oclIsTypeOf(SpecialValue))]															[comment OPEN checks if the parameter is a SpecialValue/]
								[let sv : SpecialValue = v.oclAsType(SpecialValue)]											[comment OPEN assigns the variable to be a SpecialValue/]
									[if (v.quantity <> null)]																[comment OPEN checks if the quantity is not null/]
										[if (sv.specialType=SpecialType::MISSING)]											[comment OPEN checks if the SpecialValue is MISSING/]
missing_values_[vr.valueRangeDef.name/]=None
											[if(v.quantity.oclIsTypeOf(AbsoluteValue))]										[comment OPEN checks if the quantity is an AbsoluteValue/]
												[let av : AbsoluteValue = v.quantity.oclAsType(AbsoluteValue)]				[comment OPEN assigns the variable to be an AbsoluteValue/]
if contract_pre_post.check_missing_range(belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df, field=None, 
								missing_values=missing_values_[vr.valueRangeDef.name/],
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_abs=[av.value/], origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) MissingValues:['['/][']'/] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) MissingValues:['['/][']'/] NOT VALIDATED')
												[/let]																		[comment OPEN assigns the variable to be an AbsoluteValue/]
											[elseif (v.quantity.oclIsTypeOf(Percent))]										[comment OPEN checks if the quantity is a Percent/]
												[let per : Percent = v.quantity.oclAsType(Percent)]							[comment OPEN assigns the variable to be a Percent/]
if contract_pre_post.check_missing_range(belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df, field=None, 
								missing_values=missing_values_[vr.valueRangeDef.name/],
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_rel=[per.percent/]/100, origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) MissingValues:['['/][']'/] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) MissingValues:['['/][']'/] NOT VALIDATED')
												[/let]																		[comment CLOSE assigns the variable to be a Percent/]
											[/if]																			[comment CLOSE checks if the quantity is an AbsoluteValue or a Percent/]
										[elseif (sv.specialType=SpecialType::INVALID)]										[comment OPEN checks if the SpecialValue is INVALID/]
invalid_values_[vr.valueRangeDef.name/]=None
											[if(v.quantity.oclIsTypeOf(AbsoluteValue))]										[comment OPEN checks if the quantity is an AbsoluteValue/]
												[let av : AbsoluteValue = v.quantity.oclAsType(AbsoluteValue)]				[comment OPEN assigns the variable to be an AbsoluteValue/]
if contract_pre_post.check_invalid_values(belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df, field=None, 
								invalid_values=invalid_values_[vr.valueRangeDef.name/],
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_abs=[av.value/], origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) InvalidValues:['['/][']'/] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) InvalidValues:['['/][']'/] NOT VALIDATED')
												[/let]																		[comment CLOSE assigns the variable to be an AbsoluteValue/]
											[elseif (v.quantity.oclIsTypeOf(Percent))]										[comment OPEN checks if the quantity is a Percent/]
												[let per : Percent = v.quantity.oclAsType(Percent)]							[comment OPEN assigns the variable to be a Percent/]
if contract_pre_post.check_invalid_values(belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df, field=None, 
								invalid_values=invalid_values_[vr.valueRangeDef.name/],
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_rel=[per.percent/]/100, origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) InvalidValues:['['/][']'/] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) InvalidValues:['['/][']'/] NOT VALIDATED')
												[/let]																		[comment CLOSE assigns the variable to be a Percent/]
											[/if]																			[comment CLOSE checks if the quantity is an AbsoluteValue or a Percent/]
										[elseif (sv.specialType=SpecialType::OUTLIER)]										[comment OPEN checks if the SpecialValue is OUTLIER/]
											[if(v.quantity.oclIsTypeOf(AbsoluteValue))]										[comment OPEN checks if the quantity is an AbsoluteValue/]
												[let av : AbsoluteValue = v.quantity.oclAsType(AbsoluteValue)]				[comment OPEN assigns the variable to be an AbsoluteValue/]
if contract_pre_post.check_outliers(belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df, field=None, 
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_abs=[av.value/], origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) NOT VALIDATED')
												[/let]																		[comment CLOSE assigns the variable to be an AbsoluteValue/]
											[elseif (v.quantity.oclIsTypeOf(Percent))]										[comment OPEN checks if the quantity is a Percent/]
												[let per : Percent = v.quantity.oclAsType(Percent)]							[comment OPEN assigns the variable to be a Percent/]
if contract_pre_post.check_outliers(belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df, field=None, 
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_rel=[per.percent/]/100, origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) NOT VALIDATED')
												[/let]																		[comment CLOSE assigns the variable to be a Percent/]
											[/if]																			[comment CLOSE checks if the quantity is an AbsoluteValue or a Percent/]
										[/if]																				[comment CLOSE checks if the SpecialValue is MISSING, INVALID o OUTLIER/]
									[elseif (v.quantity = null)]															[comment OPEN checks if the quantity is null/]
										[if (sv.specialType=SpecialType::MISSING)]											[comment OPEN checks if the SpecialType is MISSING/]
missing_values_[vr.valueRangeDef.name/]=None
if contract_pre_post.check_missing_range(belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df, field=None, 
								missing_values=missing_values_[vr.valueRangeDef.name/],
								quant_abs=None, quant_rel=None, quant_op=None, origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) MissingValues:['['/][']'/] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) MissingValues:['['/][']'/] NOT VALIDATED')
										[elseif (sv.specialType=SpecialType::INVALID)]										[comment OPEN checks if the SpecialType is INVALID/]
invalid_values_[vr.valueRangeDef.name/]=None
if contract_pre_post.check_invalid_values(belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df, field=None, 
								invalid_values=invalid_values_[vr.valueRangeDef.name/],
								quant_abs=None, quant_rel=None, quant_op=None, origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) InvalidValues:['['/][']'/] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) InvalidValues:['['/][']'/] NOT VALIDATED')
										[elseif (sv.specialType=SpecialType::OUTLIER)]										[comment OPEN checks if the SpecialType is OUTLIER/]
if contract_pre_post.check_outliers(belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df, field=None, 
								quant_abs=None, quant_rel=None, quant_op=None, origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) NOT VALIDATED')
										[/if]
									[/if]																					[comment CLOSE checks if the quantity is null/]
								[/let]																						[comment CLOSE assigns the variable to be a SpecialValue/]
							[/if]																							[comment CLOSE checks if the parameter is a SpecialValue/]
						[/for]																								[comment CLOSE traverse all the parameters/]
					[/for]																									[comment CLOSE traverse all the input DataDictionaries/]
				[elseif (vr.valueRangeDef.type=ContractType::POSTCONDITION)]														[comment OPEN checks if it is a Postcondition/]
					[for (dd_out : Workflow::DataDictionary | aContract.eContainer(Workflow::DataProcessing).outputPort)]	[comment OPEN traverse all the output DataDictionaries/]
						[for (v : RowValue | vr.value)]																		[comment OPEN traverse all the value parameters/]
							[if (v.oclIsTypeOf(FixValue))]																	[comment OPEN checks if the parameter is a FixValue/]
								[let fv : FixValue = v.oclAsType(FixValue)]													[comment OPEN assigns the parameter to be a FixValue/]
									[if (v.quantity <> null)]																[comment OPEN checks if the quantity is not null/]
										[if(v.quantity.oclIsTypeOf(AbsoluteValue))]											[comment OPEN checks if the quantity is an AbsoluteValue/]
											[let av : AbsoluteValue = v.quantity.oclAsType(AbsoluteValue)]					[comment OPEN assigns the parameter to be an AbsoluteValue/]
if contract_pre_post.check_fix_value_range([if (fv.dataType=DataType::String or fv.dataType=DataType::Time or fv.dataType=DataType::DateTime)]value='[fv.value/]'[else]value=[fv.value/][/if], is_substring=[if (fv.subStr=true)]True[elseif (fv.subStr=false)]False[/if], data_dictionary=[dd_out.name.replaceAll('[(),-/\\s]+', '_')/]_df, belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), field=None,
								quant_abs=[av.value/], quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) FixValue:[fv.value/] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) FixValue:[fv.value/] NOT VALIDATED')
											[/let]																			[comment CLOSE assigns the parameter to be an AbsoluteValue/]
										[elseif (v.quantity.oclIsTypeOf(Percent))]											[comment OPEN checks if the parameter is a Percent/]
											[let per : Percent = v.quantity.oclAsType(Percent)]								[comment OPEN assigns the parameter to be a Percent/]
if contract_pre_post.check_fix_value_range([if (fv.dataType=DataType::String or fv.dataType=DataType::Time or fv.dataType=DataType::DateTime)]value='[fv.value/]'[else]value=[fv.value/][/if], is_substring=[if (fv.subStr=true)]True[elseif (fv.subStr=false)]False[/if], data_dictionary=[dd_out.name.replaceAll('[(),-/\\s]+', '_')/]_df, belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), field=None,
								quant_rel=[per.percent/], quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) FixValue:[fv.value/] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) FixValue:[fv.value/] NOT VALIDATED')
											[/let]																			[comment CLOSE assigns the parameter to be a Percent/]
										[/if]																				[comment CLOSE checks if the parameter is a Percent/]
									[else]																					[comment OPEN checks if the quantity is null/]
if contract_pre_post.check_fix_value_range([if (fv.dataType=DataType::String or fv.dataType=DataType::Time or fv.dataType=DataType::DateTime)]value='[fv.value/]'[else]value=[fv.value/][/if], is_substring=[if (fv.subStr=true)]True[elseif (fv.subStr=false)]False[/if], data_dictionary=[dd_out.name.replaceAll('[(),-/\\s]+', '_')/]_df, belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), field=None,
								quant_abs=None, quant_rel=None, quant_op=None, origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) FixValue:[fv.value/] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) FixValue:[fv.value/] NOT VALIDATED')
									[/if]																					[comment CLOSE checks if the quantity is null/]
								[/let]																						[comment CLOSE assigns the parameter to be a FixValue/]
							[elseif (v.oclIsTypeOf(Interval))]																[comment OPEN checks if the parameter is an Interval/]
								[let inter : Interval = v.oclAsType(Interval)]												[comment OPEN assigns the parameter to be an Interval/]
if contract_pre_post.check_interval_range_float(left_margin=[inter.leftMargin/], right_margin=[inter.rightMargin/], data_dictionary=[dd_out.name.replaceAll('[(),-/\\s]+', '_')/]_df,
                               closure_type=Closure([if (inter.closureType=ClosureType::openOpen)]0[elseif (inter.closureType=ClosureType::openClosed)]1[elseif (inter.closureType=ClosureType::closedOpen)]2[elseif (inter.closureType=ClosureType::closedClosed)]3[/if]), belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), field_in=None, field_out=None, origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) Interval:[if (inter.closureType=ClosureType::openOpen or inter.closureType=ClosureType::openClosed)]([elseif (inter.closureType=ClosureType::closedOpen or inter.closureType=ClosureType::closedClosed)]['['/][/if][inter.leftMargin/], [inter.rightMargin/][if (inter.closureType=ClosureType::openOpen or inter.closureType=ClosureType::closedOpen)])[elseif (inter.closureType=ClosureType::closedClosed or inter.closureType=ClosureType::openClosed)][']'/][/if] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) Interval:[if (inter.closureType=ClosureType::openOpen or inter.closureType=ClosureType::openClosed)]([elseif (inter.closureType=ClosureType::closedOpen or inter.closureType=ClosureType::closedClosed)]['['/][/if][inter.leftMargin/], [inter.rightMargin/][if (inter.closureType=ClosureType::openOpen or inter.closureType=ClosureType::closedOpen)])[elseif (inter.closureType=ClosureType::closedClosed or inter.closureType=ClosureType::openClosed)][']'/][/if] NOT VALIDATED')
								[/let]																						[comment CLOSE assigns the parameter to be an Interval/]
							[elseif (v.oclIsTypeOf(SpecialValue))]															[comment OPEN checks if the parameter is a SpecialValue/]
								[let sv : SpecialValue = v.oclAsType(SpecialValue)]											[comment OPEN assigns the parameter to be a SpecialValue/]
									[if (v.quantity <> null)]																[comment OPEN checks if the quantity is not null/]
										[if (sv.specialType=SpecialType::MISSING)]											[comment OPEN checks if the SpecialValue is MISSING/]
missing_values_[vr.valueRangeDef.name/]=None
											[if(v.quantity.oclIsTypeOf(AbsoluteValue))]										[comment OPEN checks if the quantity is an AbsoluteValue/]
												[let av : AbsoluteValue = v.quantity.oclAsType(AbsoluteValue)]				[comment OPEN assigns the parameter to be an AbsoluteValue/]
if contract_pre_post.check_missing_range(belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), data_dictionary=[dd_out.name.replaceAll('[(),-/\\s]+', '_')/]_df, field=None, 
								missing_values=missing_values_[vr.valueRangeDef.name/],
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_abs=[av.value/], origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) MissingValues:['['/][']'/] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) MissingValues:['['/][']'/] NOT VALIDATED')
												[/let]																		[comment CLOSE assigns the parameter to be an AbsoluteValue/]
											[elseif (v.quantity.oclIsTypeOf(Percent))]										[comment OPEN checks if the quantity is a Percent/]
												[let per : Percent = v.quantity.oclAsType(Percent)]							[comment OPEN assigns the parameter to be a Percent/]
if contract_pre_post.check_missing_range(belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), data_dictionary=[dd_out.name.replaceAll('[(),-/\\s]+', '_')/]_df, field=None, 
								missing_values=missing_values_[vr.valueRangeDef.name/],
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_rel=[per.percent/]/100, origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) MissingValues:['['/][']'/] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) MissingValues:['['/][']'/] NOT VALIDATED')
												[/let]																		[comment CLOSE assigns the parameter to be a Percent/]
											[/if]																			[comment CLOSE checks if the quantity is an AbsoluteValue or a Percent/]
										[elseif (sv.specialType=SpecialType::INVALID)]										[comment OPEN checks if the SpecialValue is INVALID/]
invalid_values_[vr.valueRangeDef.name/]=None
											[if(v.quantity.oclIsTypeOf(AbsoluteValue))]										[comment OPEN checks if the quantity is an AbsoluteValue/]
												[let av : AbsoluteValue = v.quantity.oclAsType(AbsoluteValue)]				[comment OPEN assigns the parameter to be an AbsoluteValue/]
if contract_pre_post.check_invalid_values(belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), data_dictionary=[dd_out.name.replaceAll('[(),-/\\s]+', '_')/]_df, field=None, 
								invalid_values=invalid_values_[vr.valueRangeDef.name/],
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_abs=[av.value/], origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) InvalidValues:['['/][']'/] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) InvalidValues:['['/][']'/] NOT VALIDATED')
												[/let]																		[comment CLOSE assigns the parameter to be an AbsoluteValue/]
											[elseif (v.quantity.oclIsTypeOf(Percent))]										[comment OPEN checks if the quantity is a Percent/]
												[let per : Percent = v.quantity.oclAsType(Percent)]							[comment OPEN assigns the parameter to be a Percent/]
if contract_pre_post.check_invalid_values(belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), data_dictionary=[dd_out.name.replaceAll('[(),-/\\s]+', '_')/]_df, field=None, 
								invalid_values=invalid_values_[vr.valueRangeDef.name/],
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_rel=[per.percent/]/100, origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) InvalidValues:['['/][']'/] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) InvalidValues:['['/][']'/] NOT VALIDATED')
												[/let]																		[comment CLOSE assigns the parameter to be a Percent/]
											[/if]																			[comment CLOSE checks if the quantity is a Percent/]
										[elseif (sv.specialType=SpecialType::OUTLIER)]										[comment OPEN checks if the SpecialValue is OUTLIER/]
											[if(v.quantity.oclIsTypeOf(AbsoluteValue))]										[comment OPEN checks if the quantity is an AbsoluteValue/]
												[let av : AbsoluteValue = v.quantity.oclAsType(AbsoluteValue)]				[comment OPEN assigns the parameter to be an AbsoluteValue/]
if contract_pre_post.check_outliers(belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), data_dictionary=[dd_out.name.replaceAll('[(),-/\\s]+', '_')/]_df, field=None, 
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_abs=[av.value/], origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) NOT VALIDATED')
												[/let]																		[comment CLOSE assigns the parameter to be an AbsoluteValue/]
											[elseif (v.quantity.oclIsTypeOf(Percent))]										[comment OPEN checks if the quantity is a Percent/]
												[let per : Percent = v.quantity.oclAsType(Percent)]							[comment OPEN assigns the parameter to be a Percent/]
if contract_pre_post.check_outliers(belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), data_dictionary=[dd_out.name.replaceAll('[(),-/\\s]+', '_')/]_df, field=None, 
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_rel=[per.percent/]/100, origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) NOT VALIDATED')
												[/let]																		[comment CLOSE assigns the parameter to be a Percent/]
											[/if]																			[comment CLOSE checks if the quantity is an AbsolteValue or a Percent/]
										[/if]																				[comment CLOSE checks if the SpecialValue is MISSING, INVALID or OUTLIER/]
									[elseif (v.quantity = null)]															[comment OPEN checks if the quantity is null/]
										[if (sv.specialType=SpecialType::MISSING)]											[comment OPEN checks if the SpecialValue is MISSING/]
missing_values_[vr.valueRangeDef.name/]=None
if contract_pre_post.check_missing_range(belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), data_dictionary=[dd_out.name.replaceAll('[(),-/\\s]+', '_')/]_df, field=None, 
								missing_values=missing_values_[vr.valueRangeDef.name/],
								quant_abs=None, quant_rel=None, quant_op=None, origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) MissingValues:['['/][']'/] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) MissingValues:['['/][']'/] NOT VALIDATED')
										[elseif (sv.specialType=SpecialType::INVALID)]										[comment OPEN checks if the SpecialValue is INVALID/]
invalid_values_[vr.valueRangeDef.name/]=None
if contract_pre_post.check_invalid_values(belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), data_dictionary=[dd_out.name.replaceAll('[(),-/\\s]+', '_')/]_df, field=None, 
								invalid_values=invalid_values_[vr.valueRangeDef.name/],
								quant_abs=None, quant_rel=None, quant_op=None, origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) InvalidValues:['['/][']'/] VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) InvalidValues:['['/][']'/] NOT VALIDATED')
										[elseif (sv.specialType=SpecialType::OUTLIER)]										[comment OPEN checks if the SpecialValue is OUTLIER/]
if contract_pre_post.check_outliers(belong_op=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), data_dictionary=[dd_out.name.replaceAll('[(),-/\\s]+', '_')/]_df, field=None, 
								quant_abs=None, quant_rel=None, quant_op=None, origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) VALIDATED')
else:
	print('[vr.valueRangeDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) NOT VALIDATED')
										[/if]																				[comment CLOSE checks if the SpecialValue is MISSING, INVALID or OUTLIER/]
									[/if]																					[comment CLOSE checks if the quantity is null or not/]
								[/let]																						[comment CLOSE assigns the parameter to be a SpecialValue/]
							[/if]																							[comment CLOSE checks if the parameter is a FixValue, Interval or SpecialValue/]
						[/for]																								[comment CLOSE traverse all the value parameters/]
					[/for]																									[comment CLOSE traverse all the output DataDictionaries/]
				[/if]																										[comment CLOSE checks if it is a Precondition or a Postcondition/]
			[/let]																											[comment CLOSE assigns the contract to be a ValueRange/]
		[/if]																												[comment CLOSE Contracts of type FieldRange, ValueRange or Condition (Invariants)/]
	[/let]																													[comment CLOSE assigns the input in the contract to be of type DataDictionary/]
[/for]
[if (aContract.oclIsTypeOf(Condition))]																						[comment OPEN Contracts of type Condition (Invariants)/]
[generateCallConditionContract(aContract)/]
[/if]
[/template]


[template public generateCallConditionContract(aContract : Contract)]
[let cond : Condition = aContract.oclAsType(Condition)]																													[comment OPEN assigns the contract to be of type Condition (Invariants)/]
	[for (odf : Object | cond._in->select(odf | odf.oclIsTypeOf(DataField)))]
		[let df : DataField = odf.oclAsType(DataField)]																													[comment OPEN assigns the variable to be of type DataField/]
			[if (df.oclIsTypeOf(Continuous) and df.dataField.oclAsType(Continuous).numDecimals <> null)]
			[/if]
			[let firstIf : If = cond._if->first()]																														[comment OPEN assigns the variable to be the first If/]
				[if (firstIf.belongOp=BelongOp::BELONG)]																												[comment OPEN checks that belongOp_in is BELONG/]
[comment]The code below generates the call to invariants of type FixValue-FixValue[/comment]
					[if (firstIf.dataCondition->first().oclIsTypeOf(FixValue))]																						[comment OPEN checks that the type of the value is FixValue/]
						[let fv : FixValue = firstIf.dataCondition->first().oclAsType(FixValue)]																		[comment OPEN assigns the variable to be of type FixValue/]
							[if (firstIf._then.dataResult.oclIsTypeOf(FixValue))]																						[comment OPEN checks that the variable is of type FixValue/]
								[let fvt : FixValue = firstIf._then.dataResult.oclAsType(FixValue)]																	[comment OPEN assigns the variable to be of type FixValue/]
									[if (aContract.out->exists(df | df.oclIsTypeOf(DataField)))]																		[comment OPEN checks that the variable is of type DataField/]

input_values_list_[cond.conditionDef.name/]=['['/][for (if_cond_list : If | cond._if) separator(', ')][for (dde : DataDictionaryElement | if_cond_list.dataCondition) separator(', ')][if (dde.oclIsKindOf(RowValue))][let value : RowValue = dde.oclAsType(RowValue)][if (value.oclIsTypeOf(FixValue))][let fval : FixValue = value.oclAsType(FixValue)][if (fval.dataType=DataType::String or fval.dataType=DataType::Time or fval.dataType=DataType::DateTime)]'[fval.value/]'[else][fval.value/][/if][/let][/if][/let][/if][/for][/for][']'/]
output_values_list_[cond.conditionDef.name/]=['['/][for (if_cond_list : If | cond._if) separator(', ')][for (dde : DataDictionaryElement | if_cond_list.dataCondition) separator(', ')][if (dde.oclIsKindOf(RowValue))][let value : RowValue = dde.oclAsType(RowValue)][if (value.oclIsTypeOf(FixValue))][if (if_cond_list._then.dataResult.oclIsTypeOf(FixValue))][let fval : FixValue = if_cond_list._then.dataResult.oclAsType(FixValue)][if (fval.dataType=DataType::String or fval.dataType=DataType::Time or fval.dataType=DataType::DateTime)]'[fval.value/]'[else][fval.value/][/if][/let][/if][/if][/let][/if][/for][/for][']'/]

data_type_input_list_[cond.conditionDef.name/]=['['/][for (if_cond_list : If | cond._if) separator(', ')][for (dde : DataDictionaryElement | if_cond_list.dataCondition) separator(', ')][if (dde.oclIsKindOf(RowValue))][let value : RowValue = dde.oclAsType(RowValue)][if (value.oclIsTypeOf(FixValue))][let fval : FixValue = value.oclAsType(FixValue)][if (fv.dataType=DataType::String)]DataType(0)[elseif (fval.dataType=DataType::Time)]DataType(1)[elseif (fval.dataType=DataType::Integer)]DataType(2)[elseif (fval.dataType=DataType::DateTime)]DataType(3)[elseif (fval.dataType=DataType::Boolean)]DataType(4)[elseif (fval.dataType=DataType::Double)]DataType(5)[elseif (fval.dataType=DataType::Float)]DataType(6)[else]None)[/if][/let][/if][/let][/if][/for][/for][']'/]
data_type_output_list_[cond.conditionDef.name/]=['['/][for (if_cond_list : If | cond._if) separator(', ')][for (dde : DataDictionaryElement | if_cond_list.dataCondition) separator(', ')][if (dde.oclIsKindOf(RowValue))][let value : RowValue = dde.oclAsType(RowValue)][if (value.oclIsTypeOf(FixValue))][if (if_cond_list._then.dataResult.oclIsTypeOf(FixValue))][let fval : FixValue = if_cond_list._then.dataResult.oclAsType(FixValue)][if (fval.dataType=DataType::String)]DataType(0)[elseif (fval.dataType=DataType::Time)]DataType(1)[elseif (fval.dataType=DataType::Integer)]DataType(2)[elseif (fval.dataType=DataType::DateTime)]DataType(3)[elseif (fval.dataType=DataType::Boolean)]DataType(4)[elseif (fval.dataType=DataType::Double)]DataType(5)[elseif (fval.dataType=DataType::Float)]DataType(6)[else]None)[/if][/let][/if][/if][/let][/if][/for][/for][']'/]

is_substring_list_[cond.conditionDef.name/]=['['/][for (if_cond_list : If | cond._if) separator(', ')][for (dde : DataDictionaryElement | if_cond_list.dataCondition) separator(', ')][if (dde.oclIsKindOf(RowValue))][let value : RowValue = dde.oclAsType(RowValue)][if (value.oclIsTypeOf(FixValue))][let fval : FixValue = value.oclAsType(FixValue)][if (fval.subStr=true)]True[elseif (fval.subStr=false)]False[/if][/let][/if][/let][/if][/for][/for][']'/]

if contract_invariants.check_inv_fix_value_fix_value(data_dictionary_in=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
										data_dictionary_out=[df.dataField.out.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
										input_values_list=input_values_list_[cond.conditionDef.name/], 
										output_values_list=output_values_list_[cond.conditionDef.name/],
										is_substring_list=is_substring_list_[cond.conditionDef.name/],
										belong_op_in=Belong([if (firstIf.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										belong_op_out=Belong([if (firstIf._then.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										data_type_input_list=data_type_input_list_[cond.conditionDef.name/],
										data_type_output_list=data_type_output_list_[cond.conditionDef.name/],
										field_in='[df.dataField.displayName/]', field_out='[df.dataField.out.displayName/]', origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([df.dataField.displayName/]) InputMapValues:[for (if_cond_list : If | cond._if) separator(', ')][for (dde : DataDictionaryElement | if_cond_list.dataCondition) separator(', ')][if (dde.oclIsKindOf(RowValue))][let value : RowValue = dde.oclAsType(RowValue)][if (value.oclIsTypeOf(FixValue))][let fval : FixValue = value.oclAsType(FixValue)][fval.value/][/let][/if][/let][/if][/for][/for] OutputMapValues:[for (if_cond_list : If | cond._if) separator(', ')][for (dde : DataDictionaryElement | if_cond_list.dataCondition) separator(', ')][if (dde.oclIsKindOf(RowValue))][let value : RowValue = dde.oclAsType(RowValue)][if (value.oclIsTypeOf(FixValue))][if (if_cond_list._then.dataResult.oclIsTypeOf(FixValue))][let fval : FixValue = if_cond_list._then.dataResult.oclAsType(FixValue)][fval.value/][/let][/if][/if][/let][/if][/for][/for] VALIDATED')
else:
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([df.dataField.displayName/]) InputMapValues:[for (if_cond_list : If | cond._if) separator(', ')][for (dde : DataDictionaryElement | if_cond_list.dataCondition) separator(', ')][if (dde.oclIsKindOf(RowValue))][let value : RowValue = dde.oclAsType(RowValue)][if (value.oclIsTypeOf(FixValue))][let fval : FixValue = value.oclAsType(FixValue)][fval.value/][/let][/if][/let][/if][/for][/for] OutputMapValues:[for (if_cond_list : If | cond._if) separator(', ')][for (dde : DataDictionaryElement | if_cond_list.dataCondition) separator(', ')][if (dde.oclIsKindOf(RowValue))][let value : RowValue = dde.oclAsType(RowValue)][if (value.oclIsTypeOf(FixValue))][if (if_cond_list._then.dataResult.oclIsTypeOf(FixValue))][let fval : FixValue = if_cond_list._then.dataResult.oclAsType(FixValue)][fval.value/][/let][/if][/if][/let][/if][/for][/for] NOT VALIDATED')
									[/if]																																[comment CLOSE checks that the variable is of type DataDictionary or DataField/]
								[/let]																																	[comment CLOSE assigns the variable to be of type FixValue/]
							[/if]																																		[comment CLOSE checks that the variable is of type FixValue/]
						[/let]																																			[comment CLOSE assigns the variable to be of type FixValue/]
					[/if]																																				[comment CLOSE checks that the type of the value is FixValue/]
				[/if]																																					[comment CLOSE checks that belongOp_in is BELONG/]
			[/let]																																						[comment CLOSE assigns the variable to be the first If/]
		[/let]																																							[comment CLOSE assigns the variable to be of type DataField/]
	[/for]
	[for (odd : Object | cond._in->select(odd | odd.oclIsTypeOf(DataDictionary)))]
		[let dd_in : DataDictionary = odd.oclAsType(DataDictionary)]																									[comment OPEN assigns the variable to be of type DataField/]
			[let firstIf : If = cond._if->first()]																														[comment OPEN assigns the variable to be the first If/]
				[if (firstIf.belongOp=BelongOp::BELONG)]																												[comment OPEN checks that belongOp_in is BELONG/]
[comment]The code below generates the call to invariants of type FixValue-FixValue[/comment]
					[if (firstIf.dataCondition->first().oclIsTypeOf(FixValue))]																						[comment OPEN checks that the type of the value is FixValue/]
						[let fv : FixValue = firstIf.dataCondition->first().oclAsType(FixValue)]																		[comment OPEN assigns the variable to be of type FixValue/]
							[if (firstIf._then.dataResult.oclIsTypeOf(FixValue))]																						[comment OPEN checks that the variable is of type FixValue/]
								[let fvt : FixValue = firstIf._then.dataResult.oclAsType(FixValue)]																	[comment OPEN assigns the variable to be of type FixValue/]
									[if (aContract.out->exists(dd | dd.oclIsTypeOf(DataDictionary)))]																	[comment OPEN checks that the variable is of type DataDictionary/]
										[if (not dd_in.dataDictionary.datafield->isEmpty())]
input_values_list_[cond.conditionDef.name/]=['['/][for (if_cond_list : If | cond._if) separator(', ')][for (dde : DataDictionaryElement | if_cond_list.dataCondition) separator(', ')][if (dde.oclIsKindOf(RowValue))][let value : RowValue = dde.oclAsType(RowValue)][if (value.oclIsTypeOf(FixValue))][let fval : FixValue = value.oclAsType(FixValue)][if (fval.dataType=DataType::String or fval.dataType=DataType::Time or fval.dataType=DataType::DateTime)]'[fval.value/]'[else][fval.value/][/if][/let][/if][/let][/if][/for][/for][']'/]
output_values_list_[cond.conditionDef.name/]=['['/][for (if_cond_list : If | cond._if) separator(', ')][for (dde : DataDictionaryElement | if_cond_list.dataCondition) separator(', ')][if (dde.oclIsKindOf(RowValue))][let value : RowValue = dde.oclAsType(RowValue)][if (value.oclIsTypeOf(FixValue))][if (if_cond_list._then.dataResult.oclIsTypeOf(FixValue))][let fval : FixValue = if_cond_list._then.dataResult.oclAsType(FixValue)][if (fval.dataType=DataType::String or fval.dataType=DataType::Time or fval.dataType=DataType::DateTime)]'[fval.value/]'[else][fval.value/][/if][/let][/if][/if][/let][/if][/for][/for][']'/]

data_type_input_list_[cond.conditionDef.name/]=['['/][for (if_cond_list : If | cond._if) separator(', ')][for (dde : DataDictionaryElement | if_cond_list.dataCondition) separator(', ')][if (dde.oclIsKindOf(RowValue))][let value : RowValue = dde.oclAsType(RowValue)][if (value.oclIsTypeOf(FixValue))][let fval : FixValue = value.oclAsType(FixValue)][if (fv.dataType=DataType::String)]DataType(0)[elseif (fval.dataType=DataType::Time)]DataType(1)[elseif (fval.dataType=DataType::Integer)]DataType(2)[elseif (fval.dataType=DataType::DateTime)]DataType(3)[elseif (fval.dataType=DataType::Boolean)]DataType(4)[elseif (fval.dataType=DataType::Double)]DataType(5)[elseif (fval.dataType=DataType::Float)]DataType(6)[else]None)[/if][/let][/if][/let][/if][/for][/for][']'/]
data_type_output_list_[cond.conditionDef.name/]=['['/][for (if_cond_list : If | cond._if) separator(', ')][for (dde : DataDictionaryElement | if_cond_list.dataCondition) separator(', ')][if (dde.oclIsKindOf(RowValue))][let value : RowValue = dde.oclAsType(RowValue)][if (value.oclIsTypeOf(FixValue))][if (if_cond_list._then.dataResult.oclIsTypeOf(FixValue))][let fval : FixValue = if_cond_list._then.dataResult.oclAsType(FixValue)][if (fval.dataType=DataType::String)]DataType(0)[elseif (fval.dataType=DataType::Time)]DataType(1)[elseif (fval.dataType=DataType::Integer)]DataType(2)[elseif (fval.dataType=DataType::DateTime)]DataType(3)[elseif (fval.dataType=DataType::Boolean)]DataType(4)[elseif (fval.dataType=DataType::Double)]DataType(5)[elseif (fval.dataType=DataType::Float)]DataType(6)[else]None)[/if][/let][/if][/if][/let][/if][/for][/for][']'/]

is_substring_list_[cond.conditionDef.name/]=['['/][for (if_cond_list : If | cond._if) separator(', ')][for (dde : DataDictionaryElement | if_cond_list.dataCondition) separator(', ')][if (dde.oclIsKindOf(RowValue))][let value : RowValue = dde.oclAsType(RowValue)][if (value.oclIsTypeOf(FixValue))][let fval : FixValue = value.oclAsType(FixValue)][if (fval.subStr=true)]True[elseif (fval.subStr=false)]False[/if][/let][/if][/let][/if][/for][/for][']'/]

if contract_invariants.check_inv_fix_value_fix_value(data_dictionary_in=[dd_in.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/]_df,
										data_dictionary_out=[dd_in.dataDictionary.datafield->first().out.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
										input_values_list=input_values_list_[cond.conditionDef.name/], 
										output_values_list=output_values_list_[cond.conditionDef.name/],
										is_substring_list=is_substring_list_[cond.conditionDef.name/],
										belong_op_in=Belong([if (firstIf.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										belong_op_out=Belong([if (firstIf._then.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										data_type_input_list=data_type_input_list_[cond.conditionDef.name/],
										data_type_output_list=data_type_output_list_[cond.conditionDef.name/],
										field_in=None, field_out=None, origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) InputMapValues:[for (if_cond_list : If | cond._if) separator(', ')][for (dde : DataDictionaryElement | if_cond_list.dataCondition) separator(', ')][if (dde.oclIsKindOf(RowValue))][let value : RowValue = dde.oclAsType(RowValue)][if (value.oclIsTypeOf(FixValue))][let fval : FixValue = value.oclAsType(FixValue)][fval.value/][/let][/if][/let][/if][/for][/for] OutputMapValues:[for (if_cond_list : If | cond._if) separator(', ')][for (dde : DataDictionaryElement | if_cond_list.dataCondition) separator(', ')][if (dde.oclIsKindOf(RowValue))][let value : RowValue = dde.oclAsType(RowValue)][if (value.oclIsTypeOf(FixValue))][if (if_cond_list._then.dataResult.oclIsTypeOf(FixValue))][let fval : FixValue = if_cond_list._then.dataResult.oclAsType(FixValue)][fval.value/][/let][/if][/if][/let][/if][/for][/for] VALIDATED')
else:
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) InputMapValues:[for (if_cond_list : If | cond._if) separator(', ')][for (dde : DataDictionaryElement | if_cond_list.dataCondition) separator(', ')][if (dde.oclIsKindOf(RowValue))][let value : RowValue = dde.oclAsType(RowValue)][if (value.oclIsTypeOf(FixValue))][let fval : FixValue = value.oclAsType(FixValue)][fval.value/][/let][/if][/let][/if][/for][/for] OutputMapValues:[for (if_cond_list : If | cond._if) separator(', ')][for (dde : DataDictionaryElement | if_cond_list.dataCondition) separator(', ')][if (dde.oclIsKindOf(RowValue))][let value : RowValue = dde.oclAsType(RowValue)][if (value.oclIsTypeOf(FixValue))][if (if_cond_list._then.dataResult.oclIsTypeOf(FixValue))][let fval : FixValue = if_cond_list._then.dataResult.oclAsType(FixValue)][fval.value/][/let][/if][/if][/let][/if][/for][/for] NOT VALIDATED')
										
										[elseif (dd_in.dataDictionary.datafield->isEmpty())]
raise Exception("It is not yet contemplated to have an invariant with data dictionaries as input and output and no datafields.")

										[/if]
									[/if]
								[/let]																																	[comment CLOSE assigns the variable to be of type FixValue/]
							[/if]																																		[comment CLOSE checks that the variable is of type FixValue/]
						[/let]																																			[comment CLOSE assigns the variable to be of type FixValue/]
					[/if]																																				[comment CLOSE checks that the type of the value is FixValue/]
				[/if]																																					[comment CLOSE checks that belongOp_in is BELONG/]
			[/let]																																						[comment CLOSE assigns the variable to be the first If/]
		[/let]																																							[comment CLOSE assigns the variable to be of type DataField/]
	[/for]
	[for (if_cond : If | cond._if)]																																		[comment OPEN traverse all the If class in the contract/]
		[if (if_cond.belongOp=BelongOp::NOTBELONG)]																														[comment OPEN checks that belongOp_in is NOTBELONG/]
			[let th : Then = if_cond._then.oclAsType(Then)]																												[comment OPEN assigns the variable to be of type Then/]
				[if (cond._in->exists(df | df.oclIsTypeOf(DataField)))]																									[comment OPEN checks that the input is a DataField/]
					[for (odf : Object | cond._in->select(odf | odf.oclIsTypeOf(DataField)))]
						[let df : DataField = odf.oclAsType(DataField)]																									[comment OPEN assigns the variable to be of type DataField/]
							[if (df.oclIsTypeOf(Continuous) and df.dataField.oclAsType(Continuous).numDecimals <> null)]
							[/if]
							[for (dde : DataDictionaryElement | if_cond.dataCondition)]
								[if (dde.oclIsKindOf(RowValue))]
									[let v : RowValue = dde.oclAsType(RowValue)]
										[if (v.oclIsKindOf(CastType))]
											[if (v.oclIsTypeOf(CastType))]
												[let ctif : CastType = v.oclAsType(CastType)]																							[comment OPEN assigns the variable to be of type SpecialValue/]
[comment]The code below generates the call to invariants of type CastType-CastType[/comment]
													[if (th.dataResult.oclIsTypeOf(CastType))]																						
														[let ctthen : CastType = th.dataResult.oclAsType(CastType)]
															[if(aContract.out->exists(df | df.oclIsTypeOf(DataField)))]																[comment OPEN checks that the output is a DataField/]
if contract_invariants.check_inv_cast_type(data_dictionary_in=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
							data_dictionary_out=[df.dataField.out.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
							cast_type_in=[if (ctif.type=DataType::String)]DataType(0)[elseif (ctif.type=DataType::Time)]DataType(1)[elseif (ctif.type=DataType::Integer)]DataType(2)[elseif (ctif.type=DataType::DateTime)]DataType(3)[elseif (ctif.type=DataType::Boolean)]DataType(4)[elseif (ctif.type=DataType::Double)]DataType(5)[elseif (ctif.type=DataType::Float)]DataType(6)[else]None)[/if],
							cast_type_out=[if (ctthen.type=DataType::String)]DataType(0)[elseif (ctthen.type=DataType::Time)]DataType(1)[elseif (ctthen.type=DataType::Integer)]DataType(2)[elseif (ctthen.type=DataType::DateTime)]DataType(3)[elseif (ctthen.type=DataType::Boolean)]DataType(4)[elseif (ctthen.type=DataType::Double)]DataType(5)[elseif (ctthen.type=DataType::Float)]DataType(6)[else]None)[/if],
							belong_op_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]),
							field_in='[df.dataField.displayName/]', field_out='[df.dataField.out.displayName/]', origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([df.dataField.displayName/]) InputType:[if (ctif.type=DataType::String)]String[elseif (ctif.type=DataType::Time)]Time[elseif (ctif.type=DataType::Integer)]Integer[elseif (ctif.type=DataType::DateTime)]DateTime[elseif (ctif.type=DataType::Boolean)]Boolean[elseif (ctif.type=DataType::Double)]Double[elseif (ctif.type=DataType::Float)]Float[else]None)[/if] OutputType:[if (ctthen.type=DataType::String)]String[elseif (ctthen.type=DataType::Time)]Time[elseif (ctthen.type=DataType::Integer)]Integer[elseif (ctthen.type=DataType::DateTime)]DateTime[elseif (ctthen.type=DataType::Boolean)]Boolean[elseif (ctthen.type=DataType::Double)]Double[elseif (ctthen.type=DataType::Float)]Float[else]None)[/if] VALIDATED')
else:
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([df.dataField.displayName/]) InputType:[if (ctif.type=DataType::String)]String[elseif (ctif.type=DataType::Time)]Time[elseif (ctif.type=DataType::Integer)]Integer[elseif (ctif.type=DataType::DateTime)]DateTime[elseif (ctif.type=DataType::Boolean)]Boolean[elseif (ctif.type=DataType::Double)]Double[elseif (ctif.type=DataType::Float)]Float[else]None)[/if] OutputType:[if (ctthen.type=DataType::String)]String[elseif (ctthen.type=DataType::Time)]Time[elseif (ctthen.type=DataType::Integer)]Integer[elseif (ctthen.type=DataType::DateTime)]DateTime[elseif (ctthen.type=DataType::Boolean)]Boolean[elseif (ctthen.type=DataType::Double)]Double[elseif (ctthen.type=DataType::Float)]Float[else]None)[/if] NOT VALIDATED')
															[/if]
														[/let]
													[/if]
												[/let]
											[/if]
										[else]
if contract_invariants.check_inv_missing_value_missing_value(data_dictionary_in=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
										data_dictionary_out=[df.dataField.eContainer(Workflow::DataDictionary).out.name.replaceAll('[(),-/\\s]+', '_')/]_df,
										belong_op_in=Belong([if (if_cond.belongOp=BelongOp::BELONG)]0[else]1[/if]), belong_op_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										field_in = '[df.dataField.displayName/]', field_out='[df.dataField.out.displayName/]', origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([df.dataField.displayName/]) BelongOpIn:[if (if_cond.belongOp=BelongOp::BELONG)]Belong[else]NotBelong[/if] BelongOpOut:[if (th.belongOp=BelongOp::BELONG)]Belong[else]NotBelong[/if] VALIDATED')
else:
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([df.dataField.displayName/]) BelongOpIn:[if (if_cond.belongOp=BelongOp::BELONG)]Belong[else]NotBelong[/if] BelongOpOut:[if (th.belongOp=BelongOp::BELONG)]Belong[else]NotBelong[/if] NOT VALIDATED')
										[/if]
									[/let]
								[/if]
							[/for]
						[/let]																																			[comment CLOSE assigns the variable to be of type DataField/]
					[/for]
				[/if]
				[if (cond._in->exists(dd | dd.oclIsTypeOf(DataDictionary)))]																							[comment OPEN checks that the input is a DataDictionary/]
					[for (odd : Object | cond._in->select(odd | odd.oclIsTypeOf(DataDictionary)))]
						[let dd_in : DataDictionary = odd.oclAsType(DataDictionary)]																					[comment OPEN assigns the variable to be of type DataDictionary/]
							[if (not dd_in.dataDictionary.datafield->isEmpty())]
if contract_invariants.check_inv_missing_value_missing_value(data_dictionary_in=[dd_in.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/]_df,
										data_dictionary_out=[dd_in.dataDictionary.out.name.replaceAll('[(),-/\\s]+', '_')/]_df,
										belong_op_in=Belong([if (if_cond.belongOp=BelongOp::BELONG)]0[else]1[/if]), belong_op_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										field_in=None, field_out=None, origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) BelongOpIn:[if (if_cond.belongOp=BelongOp::BELONG)]Belong[else]NotBelong[/if] BelongOpOut:[if (th.belongOp=BelongOp::BELONG)]Belong[else]NotBelong[/if] VALIDATED')
else:
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([aContract.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) BelongOpIn:[if (if_cond.belongOp=BelongOp::BELONG)]Belong[else]NotBelong[/if] BelongOpOut:[if (th.belongOp=BelongOp::BELONG)]Belong[else]NotBelong[/if] NOT VALIDATED')

							[elseif (dd_in.dataDictionary.datafield->isEmpty())]
raise Exception("It is not yet contemplated to have an invariant with data dictionaries as input and output and no datafields.")

							[/if]
						[/let]																																			[comment CLOSE assigns the variable to be of type DataDictionary/]
					[/for]
				[/if]																																					[comment CLOSE checks that the input is a DataField or a DataDictionary/]
			[/let]																																						[comment CLOSE assigns the variable to be of type Then/]
		[/if]																																							[comment CLOSE checks that belongOp_in is NOTBELONG/]
		[if (if_cond.belongOp=BelongOp::BELONG)]																														[comment OPEN checks that belongOp_in is BELONG/]
			[if (cond._in->exists(df | df.oclIsTypeOf(DataField)))]																										[comment OPEN checks that the input is a DataField/]
				[for (odf : Object | cond.out->select(odf | odf.oclIsTypeOf(DataField)))]
					[let df : DataField = odf.oclAsType(DataField)]																										[comment OPEN assigns the variable to be of type DataField/]
						[if (df.oclIsTypeOf(Continuous) and df.dataField.oclAsType(Continuous).numDecimals <> null)]
						[/if]
						[let th : Then = if_cond._then.oclAsType(Then)]																									[comment OPEN assigns the variable to be of type Then/]
							[for (dde : DataDictionaryElement | if_cond.dataCondition)]
								[if (dde.oclIsKindOf(RowValue))]
									[let v : RowValue = dde.oclAsType(RowValue)]
										[if (v.oclIsTypeOf(Interval))]
[comment]The code below generates the call to invariants of type MathOperation[/comment]
											[if (th.dataResult.oclIsTypeOf(MathOperation))]
												[let mathOp : MathOperation = th.dataResult.oclAsType(MathOperation)]
													[if (aContract.out->exists(df | df.oclIsTypeOf(DataField)))]															[comment OPEN checks that the variable is of type DataField/]
if contract_invariants.check_inv_math_operation(data_dictionary_in=[df.dataField._in.eContainer(Workflow::DataDictionary)->first().name.replaceAll('[(),-/\\s]+', '_')/]_df,
										data_dictionary_out=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
										[if (mathOp.mathOp=MathOperator::SUM)]math_op=MathOperator(0)[elseif (mathOp.mathOp=MathOperator::SUBSTRACT)]math_op=MathOperator(1)[elseif (mathOp.mathOp=MathOperator::MULTIPLY)]math_op=MathOperator(2)[elseif (mathOp.mathOp=MathOperator::DIVIDE)]math_op=MathOperator(3)[/if],
										[for (operand : Operand | mathOp.operand)][if (operand.next_operand<>null)][if (operand.oclIsKindOf(OpField))][let fop : OpField = operand.oclAsType(OpField)]firstOperand='[fop.datafield.dataField.displayName/]', isFieldFirst=True, [/let][else][let fop : FixValue = operand.oclAsType(FixValue)]firstOperand=[fop.value/], isFieldFirst=False,[/let][/if][if (operand.next_operand.oclIsKindOf(OpField))][let sop : OpField = operand.next_operand.oclAsType(OpField)]secondOperand='[sop.datafield.dataField.displayName/]', isFieldSecond=True, [/let][else][let sop : FixValue = operand.next_operand.oclAsType(FixValue)]secondOperand=[sop.value/], isFieldSecond=False,[/let][/if][/if][/for]
										belong_op_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]), field_in='[df.dataField._in->first().displayName/]', field_out='[df.dataField.displayName/]', origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([df.dataField.displayName/]) [if (mathOp.mathOp=MathOperator::SUM)]sum([elseif (mathOp.mathOp=MathOperator::SUBSTRACT)]substract([elseif (mathOp.mathOp=MathOperator::MULTIPLY)]multiply([elseif (mathOp.mathOp=MathOperator::DIVIDE)]divide([/if][for (operand : Operand | mathOp.operand)][if (operand.next_operand<>null)][if (operand.oclIsKindOf(OpField))][let fop : OpField = operand.oclAsType(OpField)][fop.datafield.dataField.displayName/], [/let][else][let fop : FixValue = operand.oclAsType(FixValue)][fop.value/], [/let][/if][if (operand.next_operand.oclIsKindOf(OpField))][let sop : OpField = operand.next_operand.oclAsType(OpField)][sop.datafield.dataField.displayName/], [/let][else][let sop : FixValue = operand.next_operand.oclAsType(FixValue)][sop.value/], [/let][/if][/if][/for]) VALIDATED')
else:
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/][df.dataField.displayName/] [if (mathOp.mathOp=MathOperator::SUM)]sum([elseif (mathOp.mathOp=MathOperator::SUBSTRACT)]substract([elseif (mathOp.mathOp=MathOperator::MULTIPLY)]multiply([elseif (mathOp.mathOp=MathOperator::DIVIDE)]divide([/if][for (operand : Operand | mathOp.operand)][if (operand.next_operand<>null)][if (operand.oclIsKindOf(OpField))][let fop : OpField = operand.oclAsType(OpField)][fop.datafield.dataField.displayName/], [/let][else][let fop : FixValue = operand.oclAsType(FixValue)][fop.value/], [/let][/if][if (operand.next_operand.oclIsKindOf(OpField))][let sop : OpField = operand.next_operand.oclAsType(OpField)][sop.datafield.dataField.displayName/], [/let][else][let sop : FixValue = operand.next_operand.oclAsType(FixValue)][sop.value/], [/let][/if][/if][/for]) NOT VALIDATED')

													[/if]
												[/let]
											[/if]
										[/if]
									[/let]
								[/if]
							[/for]
						[/let]
					[/let]		
				[/for]
				[for (odf : Object | cond._in->select(odf | odf.oclIsTypeOf(DataField)))]
					[let df : DataField = odf.oclAsType(DataField)]																												[comment OPEN assigns the variable to be of type DataField/]
						[if (df.oclIsTypeOf(Continuous) and df.dataField.oclAsType(Continuous).numDecimals <> null)]
						[/if]
						[let th : Then = if_cond._then.oclAsType(Then)]																											[comment OPEN assigns the variable to be of type Then/]
							[for (dde : DataDictionaryElement | if_cond.dataCondition)]
								[if (dde.oclIsKindOf(RowValue))]
									[let v : RowValue = dde.oclAsType(RowValue)]
										[if (v.oclIsTypeOf(FixValue))]																											[comment OPEN checks that the type of the value is FixValue/]
											[let fv : FixValue = v.oclAsType(FixValue)]																							[comment OPEN assigns the variable to be of type FixValue/]
[comment]The code below generates the call to invariants of type FixValue-DerivedValue[/comment]
												[if (th.dataResult.oclIsTypeOf(DerivedValue))]																					[comment OPEN checks that the variable is of type DerivedValue/]
													[let derVal : DerivedValue = th.dataResult.oclAsType(DerivedValue)]															[comment OPEN assigns the variable to be of type DerivedValue/]
														[if (aContract.out->exists(df | df.oclIsTypeOf(DataField)))]															[comment OPEN checks that the variable is of type DataField/]																	[comment OPEN checks that the variable is of type DataField/]
if contract_invariants.check_inv_fix_value_derived_value(data_dictionary_in=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
										data_dictionary_out=[df.dataField.out.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
										fix_value_input=[if (fv.dataType=DataType::String or fv.dataType=DataType::Time or fv.dataType=DataType::DateTime)]'[fv.value/]'[else][fv.value/][/if],
										belong_op_in=Belong([if (if_cond.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										belong_op_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										derived_type_output=DerivedType([if (derVal.type=DerivedType::MostFrequent)]0[elseif (derVal.type=DerivedType::Previous)]1[elseif (derVal.type=DerivedType::Next)]2[/if]),
										axis_param=0, field_in='[df.dataField.displayName/]', field_out='[df.dataField.out.displayName/]', origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([df.dataField.displayName/]) FixValue:[fv.value/] To_[if (derVal.type=DerivedType::MostFrequent)]MostFrequent[elseif (derVal.type=DerivedType::Previous)]Previous[elseif (derVal.type=DerivedType::Next)]Next[/if] VALIDATED')
else:
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([df.dataField.displayName/]) FixValue:[fv.value/] To_[if (derVal.type=DerivedType::MostFrequent)]MostFrequent[elseif (derVal.type=DerivedType::Previous)]Previous[elseif (derVal.type=DerivedType::Next)]Next[/if] NOT VALIDATED')
														[/if]																													[comment CLOSE checks that the variable is of type DataDictionary or DataField/]
													[/let]																														[comment CLOSE assigns the variable to be of type DerivedValue/]
												[/if]																															[comment CLOSE checks that the variable is of type DerivedValue/]
[comment]The code below generates the call to invariants of type FixValue-NumOp[/comment]
												[if (th.dataResult.oclIsTypeOf(NumOp))]																							[comment OPEN checks that the variable is of type NumOp/]
													[let nop : NumOp = th.dataResult.oclAsType(NumOp)]																			[comment OPEN assigns the variable to be of type NumOp/]
														[if (aContract.out->exists(df | df.oclIsTypeOf(DataField)))]															[comment OPEN checks that the variable is of type DataField/]
if contract_invariants.check_inv_fix_value_num_op(data_dictionary_in=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
										data_dictionary_out=[df.dataField.out.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
										fix_value_input=[if (fv.dataType=DataType::String or fv.dataType=DataType::Time or fv.dataType=DataType::DateTime)]'[fv.value/]'[else][fv.value/][/if],
										belong_op_in=Belong([if (if_cond.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										belong_op_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										num_op_output=Operation([if (nop.operation=Operation::Interpolation)]0[elseif (nop.operation=Operation::Mean)]1[elseif (nop.operation=Operation::Median)]2[elseif (nop.operation=Operation::Closest)]3[/if]),
										axis_param=0, field_in='[df.dataField.displayName/]', field_out='[df.dataField.out.displayName/]', origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([df.dataField.displayName/])_FixValue:[fv.value/] To_[if (nop.operation=Operation::Interpolation)]Interpolation[elseif (nop.operation=Operation::Mean)]Mean[elseif (nop.operation=Operation::Median)]Median[elseif (nop.operation=Operation::Closest)]Closest[/if] VALIDATED')
else:
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([df.dataField.displayName/])_FixValue:[fv.value/] To_[if (nop.operation=Operation::Interpolation)]Interpolation[elseif (nop.operation=Operation::Mean)]Mean[elseif (nop.operation=Operation::Median)]Median[elseif (nop.operation=Operation::Closest)]Closest[/if] NOT VALIDATED')
														[/if]																													[comment CLOSE checks that the variable is of type DataDictionary or DataField/]
													[/let]																														[comment CLOSE assigns the variable to be of type NumOp/]
												[/if]																															[comment CLOSE checks that the variable is of type NumOp/]
											[/let]																																[comment CLOSE assigns the variable to be of type FixValue/]
										[/if]																																	[comment CLOSE checks that the type of the value is FixValue/]
                                        [if (v.oclIsTypeOf(Interval))]																											[comment OPEN checks that the type of the value is Interval/]
											[let int : Interval = v.oclAsType(Interval)]																						[comment OPEN assigns the variable to be of type Interval/]
[comment]The code below generates the call to invariants of type Interval-FixValue[/comment]
												[if (th.dataResult.oclIsTypeOf(FixValue) and aContract.eContainer(DataProcessing).dataProcessingDefinition.name<>'rowFilterPrimitive')]			[comment OPEN checks that the variable is of type FixValue/]
													[let fvt : FixValue = th.dataResult.oclAsType(FixValue)]																	[comment OPEN assigns the variable to be of type FixValue/]																											[comment CLOSE assigns the variable to be of type DataDictionary/]
														[if (aContract.out->exists(df | df.oclIsTypeOf(DataField)))]															[comment OPEN checks that the variable is of type DataField/]
if contract_invariants.check_inv_interval_fix_value(data_dictionary_in=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
										data_dictionary_out=[df.dataField.out.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
										left_margin=[int.leftMargin/], right_margin=[int.rightMargin/],
										closure_type=Closure([if (int.closureType=ClosureType::openOpen)]0[elseif (int.closureType=ClosureType::openClosed)]1[elseif (int.closureType=ClosureType::closedOpen)]2[elseif (int.closureType=ClosureType::closedClosed)]3[/if]),
										fix_value_output=[if (fvt.dataType=DataType::String or fvt.dataType=DataType::Time or fvt.dataType=DataType::DateTime)]'[fvt.value/]'[else][fvt.value/][/if],
										belong_op_in=Belong([if (if_cond.belongOp=BelongOp::BELONG)]0[else]1[/if]), belong_op_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										data_type_output=[if (fvt.dataType=DataType::String)]DataType(0)[elseif (fvt.dataType=DataType::Time)]DataType(1)[elseif (fvt.dataType=DataType::Integer)]DataType(2)[elseif (fvt.dataType=DataType::DateTime)]DataType(3)[elseif (fvt.dataType=DataType::Boolean)]DataType(4)[elseif (fvt.dataType=DataType::Double)]DataType(5)[elseif (fvt.dataType=DataType::Float)]DataType(6)[else]None)[/if],
										field_in='[df.dataField.displayName/]', field_out='[df.dataField.out.displayName/]', origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([df.dataField.displayName/]) Interval:[if (int.closureType=ClosureType::openOpen or int.closureType=ClosureType::openClosed)]([elseif (int.closureType=ClosureType::closedOpen or int.closureType=ClosureType::closedClosed)]['['/][/if][int.leftMargin/], [int.rightMargin/][if (int.closureType=ClosureType::openOpen or int.closureType=ClosureType::closedOpen)])[elseif (int.closureType=ClosureType::openClosed or int.closureType=ClosureType::closedClosed)][']'/][/if] FixValue:[fvt.value/] VALIDATED')
else:
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([df.dataField.displayName/]) Interval:[if (int.closureType=ClosureType::openOpen or int.closureType=ClosureType::openClosed)]([elseif (int.closureType=ClosureType::closedOpen or int.closureType=ClosureType::closedClosed)]['['/][/if][int.leftMargin/], [int.rightMargin/][if (int.closureType=ClosureType::openOpen or int.closureType=ClosureType::closedOpen)])[elseif (int.closureType=ClosureType::openClosed or int.closureType=ClosureType::closedClosed)][']'/][/if] FixValue:[fvt.value/] NOT VALIDATED')
														[/if]																													[comment CLOSE checks that the output is DataDictionary or DataField/]
													[/let]																														[comment CLOSE assigns the variable to be of type FixValue/]
												[/if]																															[comment CLOSE checks that the variable is of type FixValue/]
[comment]The code below generates the call to invariants of type Interval-DerivedValue[/comment]
												[if (th.dataResult.oclIsTypeOf(DerivedValue))]																					[comment OPEN checks that the variable is of type DerivedValue/]
													[let derVal : DerivedValue = th.dataResult.oclAsType(DerivedValue)]															[comment OPEN assigns the variable to be of type DerivedValue/]
														[if (aContract.out->exists(df | df.oclIsTypeOf(DataField)))]															[comment OPEN checks that the variable is of type DataField/]
if contract_invariants.check_inv_interval_derived_value(data_dictionary_in=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
										data_dictionary_out=[df.dataField.out.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
										left_margin=[int.leftMargin/], right_margin=[int.rightMargin/],
										closure_type=Closure([if (int.closureType=ClosureType::openOpen)]0[elseif (int.closureType=ClosureType::openClosed)]1[elseif (int.closureType=ClosureType::closedOpen)]2[elseif (int.closureType=ClosureType::closedClosed)]3[/if]),
										belong_op_in=Belong([if (if_cond.belongOp=BelongOp::BELONG)]0[else]1[/if]), belong_op_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										derived_type_output=DerivedType([if (derVal.type=DerivedType::MostFrequent)]0[elseif (derVal.type=DerivedType::Previous)]1[elseif (derVal.type=DerivedType::Next)]2[/if]),
										axis_param=0, field_in='[df.dataField.displayName/]', field_out='[df.dataField.out.displayName/]', origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([df.dataField.displayName/]) Interval:[if (int.closureType=ClosureType::openOpen or int.closureType=ClosureType::openClosed)]([elseif (int.closureType=ClosureType::closedOpen or int.closureType=ClosureType::closedClosed)]['['/][/if][int.leftMargin/], [int.rightMargin/][if (int.closureType=ClosureType::openOpen or int.closureType=ClosureType::closedOpen)])[elseif (int.closureType=ClosureType::openClosed or int.closureType=ClosureType::closedClosed)][']'/][/if] To_[if (derVal.type=DerivedType::MostFrequent)]MostFrequent[elseif (derVal.type=DerivedType::Previous)]Previous[elseif (derVal.type=DerivedType::Next)]Next[/if] VALIDATED')
else:
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([df.dataField.displayName/]) Interval:[if (int.closureType=ClosureType::openOpen or int.closureType=ClosureType::openClosed)]([elseif (int.closureType=ClosureType::closedOpen or int.closureType=ClosureType::closedClosed)]['['/][/if][int.leftMargin/], [int.rightMargin/][if (int.closureType=ClosureType::openOpen or int.closureType=ClosureType::closedOpen)])[elseif (int.closureType=ClosureType::openClosed or int.closureType=ClosureType::closedClosed)][']'/][/if] To_[if (derVal.type=DerivedType::MostFrequent)]MostFrequent[elseif (derVal.type=DerivedType::Previous)]Previous[elseif (derVal.type=DerivedType::Next)]Next[/if] NOT VALIDATED')
														[/if]																													[comment CLOSE checks that the output is DataDictionary or DataField/]
													[/let]																														[comment CLOSE assigns the variable to be of type DerivedValue/]
												[/if]																															[comment CLOSE checks that the variable is of type derivedValue/]
[comment]The code below generates the call to invariants of type Interval-NumOp[/comment]
												[if (th.dataResult.oclIsTypeOf(NumOp))]																							[comment OPEN checks that the variable is of type NumOp/]
													[let nop : NumOp = th.dataResult.oclAsType(NumOp)]																			[comment OPEN assigns the variable to be of type NumOp/]
														[if (aContract.out->exists(df | df.oclIsTypeOf(DataField)))]															[comment OPEN checks that the variable is of type DataField/]
if contract_invariants.check_inv_interval_num_op(data_dictionary_in=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
										data_dictionary_out=[df.dataField.out.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
										left_margin=[int.leftMargin/], right_margin=[int.rightMargin/],
										closure_type=Closure([if (int.closureType=ClosureType::openOpen)]0[elseif (int.closureType=ClosureType::openClosed)]1[elseif (int.closureType=ClosureType::closedOpen)]2[elseif (int.closureType=ClosureType::closedClosed)]3[/if]),
										belong_op_in=Belong([if (if_cond.belongOp=BelongOp::BELONG)]0[else]1[/if]), belong_op_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										num_op_output=Operation([if (nop.operation=Operation::Interpolation)]0[elseif (nop.operation=Operation::Mean)]1[elseif (nop.operation=Operation::Median)]2[elseif (nop.operation=Operation::Closest)]3[/if]),
										axis_param=0, field_in='[df.dataField.displayName/]', field_out='[df.dataField.out.displayName/]', origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([df.dataField.displayName/]) Interval:[if (int.closureType=ClosureType::openOpen or int.closureType=ClosureType::openClosed)]([elseif (int.closureType=ClosureType::closedOpen or int.closureType=ClosureType::closedClosed)]['['/][/if][int.leftMargin/], [int.rightMargin/][if (int.closureType=ClosureType::openOpen or int.closureType=ClosureType::closedOpen)])[elseif (int.closureType=ClosureType::openClosed or int.closureType=ClosureType::closedClosed)][']'/][/if] To_[if (nop.operation=Operation::Interpolation)]Interpolation[elseif (nop.operation=Operation::Mean)]Mean[elseif (nop.operation=Operation::Median)]Median[elseif (nop.operation=Operation::Closest)]Closest[/if] VALIDATED')
else:
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([df.dataField.displayName/]) Interval:[if (int.closureType=ClosureType::openOpen or int.closureType=ClosureType::openClosed)]([elseif (int.closureType=ClosureType::closedOpen or int.closureType=ClosureType::closedClosed)]['['/][/if][int.leftMargin/], [int.rightMargin/][if (int.closureType=ClosureType::openOpen or int.closureType=ClosureType::closedOpen)])[elseif (int.closureType=ClosureType::openClosed or int.closureType=ClosureType::closedClosed)][']'/][/if] To_[if (nop.operation=Operation::Interpolation)]Interpolation[elseif (nop.operation=Operation::Mean)]Mean[elseif (nop.operation=Operation::Median)]Median[elseif (nop.operation=Operation::Closest)]Closest[/if] NOT VALIDATED')
														[/if]																													[comment CLOSE checks that the output is DataDictionary or DataField/]
													[/let]																														[comment CLOSE assigns the variable to be of type NumOp/]
												[/if]																															[comment CLOSE checks that the variable is of type NumOp/]
											[/let]																																[comment CLOSE assigns the variable to be of type Interval/]
										[/if]																																	[comment CLOSE checks that the type of the value is Interval/]
										[if (v.oclIsTypeOf(SpecialValue))]																										[comment OPEN checks that the type of the value is SpecialValue/]
											[let sv : SpecialValue = v.oclAsType(SpecialValue)]																					[comment OPEN assigns the variable to be of type SpecialValue/]
[comment]The code below generates the call to invariants of type SpecialValue-FixValue[/comment]
												[if (th.dataResult.oclIsTypeOf(FixValue))]																						[comment OPEN checks that the type of the result is FixValue/]
													[let fixVal : FixValue = th.dataResult.oclAsType(FixValue)]																	[comment OPEN assigns the variable to be of type FixValue/]
														[if (sv.specialType=SpecialType::MISSING)]																				[comment OPEN checks that SpecialType is MISSING/]
missing_values_[cond.conditionDef.name/]=['['/][for (mv : ValueField | df.dataField.missingValues) separator(', ')][mv.value/][/for][']'/]
														[elseif (sv.specialType=SpecialType::INVALID)]																			[comment OPEN checks that SpecialType is INVALID/]
invalid_values_[cond.conditionDef.name/]=['['/][for (mv : ValueField | df.dataField.invalidValues) separator(', ')][mv.value/][/for][']'/]
														[/if]																													[comment CLOSE checks that SpecialType is MISSING or INVALID/]																												[comment CLOSE assigns the variable to be of type DataDictionary/]
														[if(aContract.out->exists(df | df.oclIsTypeOf(DataField)))]																[comment OPEN checks that the output is a DataField/]
if contract_invariants.check_inv_special_value_fix_value(data_dictionary_in=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
							data_dictionary_out=[df.dataField.out.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
							special_type_input=SpecialType([if (sv.specialType=SpecialType::MISSING)]0[elseif (sv.specialType=SpecialType::INVALID)]1[elseif (sv.specialType=SpecialType::OUTLIER)]2[/if]),
							fix_value_output=[if (fixVal.dataType=DataType::String or fixVal.dataType=DataType::Time or fixVal.dataType=DataType::DateTime)]'[fixVal.value/]'[else][fixVal.value/][/if],
							belong_op_in=Belong([if (if_cond.belongOp=BelongOp::BELONG)]0[else]1[/if]),
							belong_op_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]),
							data_type_output=[if (fixVal.dataType=DataType::String)]DataType(0)[elseif (fixVal.dataType=DataType::Time)]DataType(1)[elseif (fixVal.dataType=DataType::Integer)]DataType(2)[elseif (fixVal.dataType=DataType::DateTime)]DataType(3)[elseif (fixVal.dataType=DataType::Boolean)]DataType(4)[elseif (fixVal.dataType=DataType::Double)]DataType(5)[elseif (fixVal.dataType=DataType::Float)]DataType(6)[else]None)[/if],
							missing_values=[if (sv.specialType=SpecialType::MISSING)]missing_values_[cond.conditionDef.name/][elseif (sv.specialType=SpecialType::INVALID)]invalid_values_[cond.conditionDef.name/][else]None[/if], 
							axis_param=0, field_in='[df.dataField.displayName/]', field_out='[df.dataField.out.displayName/]', origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([df.dataField.displayName/]) [if (sv.specialType=SpecialType::MISSING)]MISSING[elseif (sv.specialType=SpecialType::INVALID)]INVALID[elseif (sv.specialType=SpecialType::OUTLIER)]OUTLIER[/if] FixValue:[fixVal.value/] VALIDATED')
else:
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([df.dataField.displayName/]) [if (sv.specialType=SpecialType::MISSING)]MISSING[elseif (sv.specialType=SpecialType::INVALID)]INVALID[elseif (sv.specialType=SpecialType::OUTLIER)]OUTLIER[/if] FixValue:[fixVal.value/] NOT VALIDATED')
														[/if]																													[comment CLOSE checks that the output is a DataDictionary or a DataField/]
													[/let]																														[comment CLOSE assigns the variable to be of type FixValue/]
												[/if]																															[comment CLOSE checks that the type of the result is FixValue/]
[comment]The code below generates the call to invariants of type SpecialValue-DerivedValue[/comment]
												[if (th.dataResult.oclIsTypeOf(DerivedValue))]																					[comment OPEN checks that the type of the result is DerivedValue/]
													[let derVal : DerivedValue = th.dataResult.oclAsType(DerivedValue)]															[comment OPEN assigns the variable to be of type DerivedValue/]
														[if (sv.specialType=SpecialType::MISSING)]																				[comment OPEN checks that SpecialType is MISSING/]
missing_values_[cond.conditionDef.name/]=['['/][for (mv : ValueField | df.dataField.missingValues) separator(', ')][mv.value/][/for][']'/]
														[elseif (sv.specialType=SpecialType::INVALID)]																			[comment OPEN checks that SpecialType is INVALID/]
invalid_values_[cond.conditionDef.name/]=['['/][for (mv : ValueField | df.dataField.invalidValues) separator(', ')][mv.value/][/for][']'/]
														[/if]																													[comment CLOSE checks that SpecialType is MISSING or INVALID/]																											[comment CLOSE assigns the variable to be of type DataDictionary/]
														[if (aContract.out->exists(df | df.oclIsTypeOf(DataField)))]															[comment OPEN checks that the output is a DataField/]
if contract_invariants.check_inv_special_value_derived_value(data_dictionary_in=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
							data_dictionary_out=[df.dataField.out.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
							belong_op_in=Belong([if (if_cond.belongOp=BelongOp::BELONG)]0[else]1[/if]),
							belong_op_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]),
							special_type_input=SpecialType([if (sv.specialType=SpecialType::MISSING)]0[elseif (sv.specialType=SpecialType::INVALID)]1[elseif (sv.specialType=SpecialType::OUTLIER)]2[/if]),
							derived_type_output=DerivedType([if (derVal.type=DerivedType::MostFrequent)]0[elseif (derVal.type=DerivedType::Previous)]1[elseif (derVal.type=DerivedType::Next)]2[/if]),
							missing_values=[if (sv.specialType=SpecialType::MISSING)]missing_values_[cond.conditionDef.name/][elseif (sv.specialType=SpecialType::INVALID)]invalid_values_[cond.conditionDef.name/][else]None[/if], axis_param=0, field_in='[df.dataField.displayName/]', field_out='[df.dataField.out.displayName/]', origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([df.dataField.displayName/]) [if (sv.specialType=SpecialType::MISSING)]MISSING[elseif (sv.specialType=SpecialType::INVALID)]INVALID[elseif (sv.specialType=SpecialType::OUTLIER)]OUTLIER[/if]_to_[if (derVal.type=DerivedType::MostFrequent)]MostFrequent[elseif (derVal.type=DerivedType::Previous)]Previous[elseif (derVal.type=DerivedType::Next)]Next[/if] VALIDATED')
else:
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([df.dataField.displayName/]) [if (sv.specialType=SpecialType::MISSING)]MISSING[elseif (sv.specialType=SpecialType::INVALID)]INVALID[elseif (sv.specialType=SpecialType::OUTLIER)]OUTLIER[/if]_to_[if (derVal.type=DerivedType::MostFrequent)]MostFrequent[elseif (derVal.type=DerivedType::Previous)]Previous[elseif (derVal.type=DerivedType::Next)]Next[/if] NOT VALIDATED')
														[/if]																													[comment CLOSE checks that the output is a DataField/]
													[/let]																														[comment CLOSE assigns the variable to be of type DerivedValue/]
												[/if]																															[comment CLOSE checks that the type of the result is DerivedValue/]
[comment]The code below generates the call to invariants of type SpecialValue-NumOp[/comment]
												[if (th.dataResult.oclIsTypeOf(NumOp))]																							[comment OPEN checks that the type of the result is NumOp/]
													[let nop : NumOp = th.dataResult.oclAsType(NumOp)]																			[comment OPEN assigns the variable to be of type NumOp/]
														[if (sv.specialType=SpecialType::MISSING)]																				[comment OPEN checks that SpecialType is MISSING/]
missing_values_[cond.conditionDef.name/]=['['/][for (mv : ValueField | df.dataField.missingValues) separator(', ')][mv.value/][/for][']'/]
														[elseif (sv.specialType=SpecialType::INVALID)]																			[comment OPEN checks that SpecialType is INVALID/]
invalid_values_[cond.conditionDef.name/]=['['/][for (mv : ValueField | df.dataField.invalidValues) separator(', ')][mv.value/][/for][']'/]
														[/if]																													[comment CLOSE checks that SpecialType is MISSING or INVALID/]
														[if (aContract.out->exists(df | df.oclIsTypeOf(DataField)))]															[comment OPEN checks that the output is a DataField/]
if contract_invariants.check_inv_special_value_num_op(data_dictionary_in=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
										data_dictionary_out=[df.dataField.out.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
										belong_op_in=Belong([if (if_cond.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										belong_op_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										special_type_input=SpecialType([if (sv.specialType=SpecialType::MISSING)]0[elseif (sv.specialType=SpecialType::INVALID)]1[elseif (sv.specialType=SpecialType::OUTLIER)]2[/if]),
										num_op_output=Operation([if (nop.operation=Operation::Interpolation)]0[elseif (nop.operation=Operation::Mean)]1[elseif (nop.operation=Operation::Median)]2[elseif (nop.operation=Operation::Closest)]3[/if]),
										missing_values=[if (sv.specialType=SpecialType::MISSING)]missing_values_[cond.conditionDef.name/][elseif (sv.specialType=SpecialType::INVALID)]invalid_values_[cond.conditionDef.name/][else]None[/if], axis_param=0, field_in='[df.dataField.displayName/]', field_out='[df.dataField.out.displayName/]', origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([df.dataField.displayName/]) [if (sv.specialType=SpecialType::MISSING)]MISSING[elseif (sv.specialType=SpecialType::INVALID)]INVALID[elseif (sv.specialType=SpecialType::OUTLIER)]OUTLIER[/if]_to_[if (nop.operation=Operation::Interpolation)]Interpolation[elseif (nop.operation=Operation::Mean)]Mean[elseif (nop.operation=Operation::Median)]Median[elseif (nop.operation=Operation::Closest)]Closest[/if] VALIDATED')
else:
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([df.dataField.displayName/]) [if (sv.specialType=SpecialType::MISSING)]MISSING[elseif (sv.specialType=SpecialType::INVALID)]INVALID[elseif (sv.specialType=SpecialType::OUTLIER)]OUTLIER[/if]_to_[if (nop.operation=Operation::Interpolation)]Interpolation[elseif (nop.operation=Operation::Mean)]Mean[elseif (nop.operation=Operation::Median)]Median[elseif (nop.operation=Operation::Closest)]Closest[/if] NOT VALIDATED')
														[/if]																													[comment CLOSE checks that the output is a DataDictionary or a DataField/]
													[/let]																														[comment CLOSE assigns the variable to be of type NumOp/]
												[/if]																															[comment CLOSE checks that the type of the result is NumOp/]
											[/let]																																[comment CLOSE assigns the variable to be of type SpecialValue/]
										[/if]																																	[comment CLOSE checks that the type of the value is FixValue or SpecialValue (if at the beginning)/]
										[if (v.oclIsTypeOf(CastType))]
											[let ctif : CastType = v.oclAsType(CastType)]																						[comment OPEN assigns the variable to be of type SpecialValue/]
[comment]The code below generates the call to invariants of type CastType-CastType[/comment]
												[if (th.dataResult.oclIsTypeOf(CastType))]																						
													[let ctthen : CastType = th.dataResult.oclAsType(CastType)]
														[if(aContract.out->exists(df | df.oclIsTypeOf(DataField)))]																[comment OPEN checks that the output is a DataField/]
if contract_invariants.check_inv_cast_type(data_dictionary_in=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
							data_dictionary_out=[df.dataField.out.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
							cast_type_in=[if (ctif.type=DataType::String)]DataType(0)[elseif (ctif.type=DataType::Time)]DataType(1)[elseif (ctif.type=DataType::Integer)]DataType(2)[elseif (ctif.type=DataType::DateTime)]DataType(3)[elseif (ctif.type=DataType::Boolean)]DataType(4)[elseif (ctif.type=DataType::Double)]DataType(5)[elseif (ctif.type=DataType::Float)]DataType(6)[else]None)[/if],
							cast_type_out=[if (ctthen.type=DataType::String)]DataType(0)[elseif (ctthen.type=DataType::Time)]DataType(1)[elseif (ctthen.type=DataType::Integer)]DataType(2)[elseif (ctthen.type=DataType::DateTime)]DataType(3)[elseif (ctthen.type=DataType::Boolean)]DataType(4)[elseif (ctthen.type=DataType::Double)]DataType(5)[elseif (ctthen.type=DataType::Float)]DataType(6)[else]None)[/if],
							belong_op_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]),
							field_in='[df.dataField.displayName/]', field_out='[df.dataField.out.displayName/]', origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([df.dataField.displayName/]) InputType:[if (ctif.type=DataType::String)]String[elseif (ctif.type=DataType::Time)]Time[elseif (ctif.type=DataType::Integer)]Integer[elseif (ctif.type=DataType::DateTime)]DateTime[elseif (ctif.type=DataType::Boolean)]Boolean[elseif (ctif.type=DataType::Double)]Double[elseif (ctif.type=DataType::Float)]Float[else]None)[/if] OutputType:[if (ctthen.type=DataType::String)]String[elseif (ctthen.type=DataType::Time)]Time[elseif (ctthen.type=DataType::Integer)]Integer[elseif (ctthen.type=DataType::DateTime)]DateTime[elseif (ctthen.type=DataType::Boolean)]Boolean[elseif (ctthen.type=DataType::Double)]Double[elseif (ctthen.type=DataType::Float)]Float[else]None)[/if] VALIDATED')
else:
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([df.dataField.displayName/]) InputType:[if (ctif.type=DataType::String)]String[elseif (ctif.type=DataType::Time)]Time[elseif (ctif.type=DataType::Integer)]Integer[elseif (ctif.type=DataType::DateTime)]DateTime[elseif (ctif.type=DataType::Boolean)]Boolean[elseif (ctif.type=DataType::Double)]Double[elseif (ctif.type=DataType::Float)]Float[else]None)[/if] OutputType:[if (ctthen.type=DataType::String)]String[elseif (ctthen.type=DataType::Time)]Time[elseif (ctthen.type=DataType::Integer)]Integer[elseif (ctthen.type=DataType::DateTime)]DateTime[elseif (ctthen.type=DataType::Boolean)]Boolean[elseif (ctthen.type=DataType::Double)]Double[elseif (ctthen.type=DataType::Float)]Float[else]None)[/if] NOT VALIDATED')
														[/if]
													[/let]
												[/if]
											[/let]
										[/if]
										[if (v.oclIsTypeOf(Interval))]
[comment]The code below generates the call to invariants of type Join[/comment]

											[if (th.dataResult.oclIsTypeOf(Join))]																						
												[let jointhen : Join = th.dataResult.oclAsType(Join)]
dictionary_[th.thenDefinition.name/]={[for (operand : Operand | jointhen.operand)][if (operand.previous_operand=null)][if (operand.oclIsKindOf(OpField))][let field : OpField=operand.oclAsType(OpField)]'[field.datafield.dataField.displayName/]': True[/let][elseif (operand.oclIsKindOf(FixValue))][let fv : FixValue=operand.oclAsType(FixValue)]'[fv.value/]': False[/let][/if][if (operand.next_operand<>null)][joinOperands(operand.next_operand)/][/if][/if][/for]}
													[if(aContract.out->exists(df | df.oclIsTypeOf(DataField)))]
if contract_invariants.check_inv_join(data_dictionary_in=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
							data_dictionary_out=[df.dataField.eContainer(Workflow::DataDictionary).out.name.replaceAll('[(),-/\\s]+', '_')/]_df,
							dictionary=dictionary_[th.thenDefinition.name/],
							field_out='[df.dataField.eContainer(Workflow::DataDictionary).out.datafield->first().displayName/]', origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([df.dataField.displayName/]) JoinInputs:[for (operand : Operand | jointhen.operand)][if (operand.previous_operand=null)][if (operand.oclIsKindOf(OpField))][let field : OpField=operand.oclAsType(OpField)][field.datafield.dataField.displayName/][/let][elseif (operand.oclIsKindOf(FixValue))][let fv : FixValue=operand.oclAsType(FixValue)][fv.value/][/let][/if][/if][/for] VALIDATED')
else:
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([df.dataField.displayName/]) JoinInputs:[for (operand : Operand | jointhen.operand)][if (operand.previous_operand=null)][if (operand.oclIsKindOf(OpField))][let field : OpField=operand.oclAsType(OpField)][field.datafield.dataField.displayName/][/let][elseif (operand.oclIsKindOf(FixValue))][let fv : FixValue=operand.oclAsType(FixValue)][fv.value/][/let][/if][/if][/for] NOT VALIDATED')
													[/if]
												[/let]
											[/if]
										[/if]
									[/let]
								[/if]
							[/for]																																		[comment CLOSE traverse all the values associated to the contract/]
						[/let]																																			[comment CLOSE assigns the variable to be of type Then/]
					[/let]																																				[comment CLOSE assigns the variable to be of type DataField/]
				[/for]
			[/if]																																						[comment CLOSE checks that the input is a DataField/]
			[if (cond._in->exists(dd | dd.oclIsTypeOf(DataDictionary)))]
[generateCallConditionContractDataDictionary(cond, if_cond)/]
			[/if]
		[/if]																																							[comment CLOSE checks that belongOp_in is BELONG/]
	[/for]																																								[comment CLOSE traverse all the If class in the contract/]

	[if (cond._then->first().dataResult.oclIsTypeOf(FixValue) and cond._then->first()._if.dataCondition->first().oclIsTypeOf(Interval) and aContract.eContainer(DataProcessing).dataProcessingDefinition.name='rowFilterPrimitive')]
columns_list_[cond.name.replaceAll('[(),-/\\s]+', '_')/]=['['/][for (obj : Object | cond._in) separator(', ')][if (obj.oclIsKindOf(DataField))][let df : DataField = obj.oclAsType(DataField)]'[df.dataField.displayName/]'[/let][/if][/for][']'/]
filter_fix_value_list_[cond.name.replaceAll('[(),-/\\s]+', '_')/]=['['/][for (dde : DataDictionaryElement | cond._then.dataResult)][if (dde.oclIsKindOf(FixValue))][let fv : FixValue = dde.oclAsType(FixValue)][if (fv.dataType=DataType::Boolean or fv.dataType=DataType::Double or fv.dataType=DataType::Float or fv.dataType=DataType::Integer)][fv.value/][elseif (fv.dataType=DataType::Date or fv.dataType=DataType::DateTime or fv.dataType=DataType::String)]'[fv.value/]'[/if][/let][/if][/for][']'/]
[comment]The code below generates the call to invariants of type filterRowPrimitive[/comment]

		[for (obj : Object | cond._in)]
			[if (obj.oclIsKindOf(DataField))]
				[let df : DataField = obj.oclAsType(DataField)]
if contract_invariants.check_inv_filter_rows_primitive(data_dictionary_in=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
										data_dictionary_out=[df.dataField.eContainer(Workflow::DataDictionary).out.name.replaceAll('[(),-/\\s]+', '_')/]_df,
										columns=columns_list_[cond.name.replaceAll('[(),-/\\s]+', '_')/],
										filter_fix_value_list=filter_fix_value_list_[cond.name.replaceAll('[(),-/\\s]+', '_')/],
										filter_type=FilterType.[if (cond.eContainer(DataProcessing).parameter->first().oclIsKindOf(FilterValue))][let fv : FilterValue = cond.eContainer(DataProcessing).parameter->first().oclAsType(FilterValue)][fv.filterType/][/let][/if], origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([for (obj : Object | cond._in) separator(', ')][if (obj.oclIsKindOf(DataField))][let df : DataField = obj.oclAsType(DataField)][df.dataField.displayName/][/let][/if][/for]) FilterType:[if (cond.eContainer(DataProcessing).parameter->first().oclIsKindOf(FilterValue))][let fv : FilterValue = cond.eContainer(DataProcessing).parameter->first().oclAsType(FilterValue)][fv.filterType/][/let][/if] FixValueList:['['/][for (dde : DataDictionaryElement | cond._then.dataResult)][if (dde.oclIsKindOf(FixValue))][let fv : FixValue = dde.oclAsType(FixValue)][fv.value/][/let][/if][/for][']'/] VALIDATED')
else:
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([for (obj : Object | cond._in) separator(', ')][if (obj.oclIsKindOf(DataField))][let df : DataField = obj.oclAsType(DataField)][df.dataField.displayName/][/let][/if][/for]) FilterType:[if (cond.eContainer(DataProcessing).parameter->first().oclIsKindOf(FilterValue))][let fv : FilterValue = cond.eContainer(DataProcessing).parameter->first().oclAsType(FilterValue)][fv.filterType/][/let][/if] FixValueList:['['/][for (dde : DataDictionaryElement | cond._then.dataResult)][if (dde.oclIsKindOf(FixValue))][let fv : FixValue = dde.oclAsType(FixValue)][fv.value/][/let][/if][/for][']'/] NOT VALIDATED')
				[/let]
			[/if]
		[/for]
	[/if]
	[if (cond._then->first().dataResult.oclIsTypeOf(Interval) and cond._then->first()._if.dataCondition->first().oclIsTypeOf(Interval))]
columns_list_[cond.name.replaceAll('[(),-/\\s]+', '_')/]=['['/][for (obj : Object | cond._in) separator(', ')][if (obj.oclIsKindOf(DataField))][let df : DataField = obj.oclAsType(DataField)]'[df.dataField.displayName/]'[/let][/if][/for][']'/]
left_margin_list_[cond.name.replaceAll('[(),-/\\s]+', '_')/]=['['/][for (then_cond_list : Then | cond._then) separator(', ')][if (then_cond_list.dataResult.oclIsKindOf(RowValue))][let value : RowValue = then_cond_list.dataResult.oclAsType(RowValue)][if (value.oclIsTypeOf(Interval))][let int : Interval = value.oclAsType(Interval)][int.leftMargin/][/let][/if][/let][/if][/for][']'/]
right_margin_list_[cond.name.replaceAll('[(),-/\\s]+', '_')/]=['['/][for (then_cond_list : Then | cond._then) separator(', ')][if (then_cond_list.dataResult.oclIsKindOf(RowValue))][let value : RowValue = then_cond_list.dataResult.oclAsType(RowValue)][if (value.oclIsTypeOf(Interval))][let int : Interval = value.oclAsType(Interval)][int.rightMargin/][/let][/if][/let][/if][/for][']'/]
closure_type_list_[cond.name.replaceAll('[(),-/\\s]+', '_')/]=['['/][for (then_cond_list : Then | cond._then) separator(', ')][if (then_cond_list.dataResult.oclIsKindOf(RowValue))][let value : RowValue = then_cond_list.dataResult.oclAsType(RowValue)][if (value.oclIsTypeOf(Interval))][let int : Interval = value.oclAsType(Interval)]Closure.[int.closureType/][/let][/if][/let][/if][/for][']'/]
[comment]The code below generates the call to invariants of type filterRowRange[/comment]

		[for (obj : Object | cond._in)]
			[if (obj.oclIsKindOf(DataField))]
				[let df : DataField = obj.oclAsType(DataField)]
if contract_invariants.check_inv_filter_rows_range(data_dictionary_in=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
										data_dictionary_out=[df.dataField.eContainer(Workflow::DataDictionary).out.name.replaceAll('[(),-/\\s]+', '_')/]_df,
										columns=columns_list_[cond.name.replaceAll('[(),-/\\s]+', '_')/],
										left_margin_list=left_margin_list_[cond.name.replaceAll('[(),-/\\s]+', '_')/], right_margin_list=right_margin_list_[cond.name.replaceAll('[(),-/\\s]+', '_')/],
										closure_type_list=closure_type_list_[cond.name.replaceAll('[(),-/\\s]+', '_')/],
										filter_type=FilterType.[if (cond.eContainer(DataProcessing).parameter->first().oclIsKindOf(FilterValue))][let fv : FilterValue = cond.eContainer(DataProcessing).parameter->first().oclAsType(FilterValue)][fv.filterType/][/let][/if], origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([for (obj : Object | cond._in) separator(', ')][if (obj.oclIsKindOf(DataField))][let df : DataField = obj.oclAsType(DataField)][df.dataField.displayName/][/let][/if][/for]) FilterType:[if (cond.eContainer(DataProcessing).parameter->first().oclIsKindOf(FilterValue))][let fv : FilterValue = cond.eContainer(DataProcessing).parameter->first().oclAsType(FilterValue)][fv.filterType/][/let][/if] LeftMarginList:['['/][for (then_cond_list : Then | cond._then) separator(', ')][if (then_cond_list.dataResult.oclIsKindOf(RowValue))][let value : RowValue = then_cond_list.dataResult.oclAsType(RowValue)][if (value.oclIsTypeOf(Interval))][let int : Interval = value.oclAsType(Interval)][int.leftMargin/][/let][/if][/let][/if][/for][']'/] RightMarginList:['['/][for (then_cond_list : Then | cond._then) separator(', ')][if (then_cond_list.dataResult.oclIsKindOf(RowValue))][let value : RowValue = then_cond_list.dataResult.oclAsType(RowValue)][if (value.oclIsTypeOf(Interval))][let int : Interval = value.oclAsType(Interval)][int.rightMargin/][/let][/if][/let][/if][/for][']'/] ClosureTypeList:['['/][for (then_cond_list : Then | cond._then) separator(', ')][if (then_cond_list.dataResult.oclIsKindOf(RowValue))][let value : RowValue = then_cond_list.dataResult.oclAsType(RowValue)][if (value.oclIsTypeOf(Interval))][let int : Interval = value.oclAsType(Interval)]Closure.[int.closureType/][/let][/if][/let][/if][/for][']'/] VALIDATED')
else:
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([for (obj : Object | cond._in) separator(', ')][if (obj.oclIsKindOf(DataField))][let df : DataField = obj.oclAsType(DataField)][df.dataField.displayName/][/let][/if][/for]) FilterType:[if (cond.eContainer(DataProcessing).parameter->first().oclIsKindOf(FilterValue))][let fv : FilterValue = cond.eContainer(DataProcessing).parameter->first().oclAsType(FilterValue)][fv.filterType/][/let][/if] LeftMarginList:['['/][for (then_cond_list : Then | cond._then) separator(', ')][if (then_cond_list.dataResult.oclIsKindOf(RowValue))][let value : RowValue = then_cond_list.dataResult.oclAsType(RowValue)][if (value.oclIsTypeOf(Interval))][let int : Interval = value.oclAsType(Interval)][int.leftMargin/][/let][/if][/let][/if][/for][']'/] RightMarginList:['['/][for (then_cond_list : Then | cond._then) separator(', ')][if (then_cond_list.dataResult.oclIsKindOf(RowValue))][let value : RowValue = then_cond_list.dataResult.oclAsType(RowValue)][if (value.oclIsTypeOf(Interval))][let int : Interval = value.oclAsType(Interval)][int.rightMargin/][/let][/if][/let][/if][/for][']'/] ClosureTypeList:['['/][for (then_cond_list : Then | cond._then) separator(', ')][if (then_cond_list.dataResult.oclIsKindOf(RowValue))][let value : RowValue = then_cond_list.dataResult.oclAsType(RowValue)][if (value.oclIsTypeOf(Interval))][let int : Interval = value.oclAsType(Interval)]Closure.[int.closureType/][/let][/if][/let][/if][/for][']'/] NOT VALIDATED')
				[/let]
			[/if]
		[/for]
	[/if]
	[if (cond._then->first().dataResult.oclIsTypeOf(SpecialValue) and cond._then->first()._if.dataCondition->first().oclIsTypeOf(Interval))]
cols_special_type_values_[cond.name.replaceAll('[(),-/\\s]+', '_')/]={[for (th2 : Then | cond._then) separator(', ')][if (th2.dataResult.oclIsKindOf(SpecialValue))][let spVal : SpecialValue = th2.dataResult.oclAsType(SpecialValue)][for (obj : Object | cond._in->select(odf | odf.oclIsTypeOf(DataField))) separator(', ')][let df : DataField = obj.oclAsType(DataField)]'[df.dataField.displayName/]':{[if (spVal.specialType=SpecialType::MISSING)]'missing': ['['/][for (mv : ValueField | df.dataField.missingValues) separator(', ')][if (df.dataField.dataType=DataType::String or df.dataField.dataType=DataType::Time or df.dataField.dataType=DataType::DateTime)]'[mv.value/]'[else][mv.value/][/if][/for][']'/][elseif(spVal.specialType=SpecialType::INVALID)]'invalid': ['['/][for (iv : ValueField | df.dataField.invalidValues) separator(', ')][if (df.dataField.dataType=DataType::String or df.dataField.dataType=DataType::Time or df.dataField.dataType=DataType::DateTime)]'[iv.value/]'[else][iv.value/][/if][/for][']'/][elseif(spVal.specialType=SpecialType::OUTLIER)]'outlier': True[/if][/let][/for]}[/let][/if][/for]}
[comment]The code below generates the call to invariants of type filterRowSpecialValue[/comment]

		[for (obj : Object | cond._in)]
			[if (obj.oclIsKindOf(DataField))]
				[let df : DataField = obj.oclAsType(DataField)]
if contract_invariants.check_inv_filter_rows_special_values(data_dictionary_in=[df.dataField.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
										data_dictionary_out=[df.dataField.eContainer(Workflow::DataDictionary).out.name.replaceAll('[(),-/\\s]+', '_')/]_df,
										cols_special_type_values=cols_special_type_values_[cond.name.replaceAll('[(),-/\\s]+', '_')/],
										filter_type=FilterType.[if (cond.eContainer(DataProcessing).parameter->first().oclIsKindOf(FilterValue))][let fv : FilterValue = cond.eContainer(DataProcessing).parameter->first().oclAsType(FilterValue)][fv.filterType/][/let][/if], origin_function="[aContract.eContainer(DataProcessing).origin_function/]"):
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([for (obj : Object | cond._in) separator(', ')][if (obj.oclIsKindOf(DataField))][let df : DataField = obj.oclAsType(DataField)][df.dataField.displayName/][/let][/if][/for]) FilterType:[if (cond.eContainer(DataProcessing).parameter->first().oclIsKindOf(FilterValue))][let fv : FilterValue = cond.eContainer(DataProcessing).parameter->first().oclAsType(FilterValue)][fv.filterType/][/let][/if] SpecialValues: [for (th2 : Then | cond._then) separator(', ')][if (th2.dataResult.oclIsKindOf(SpecialValue))][let spVal : SpecialValue = th2.dataResult.oclAsType(SpecialValue)][for (obj : Object | cond._in->select(odf | odf.oclIsTypeOf(DataField))) separator(', ')][let df : DataField = obj.oclAsType(DataField)][df.dataField.displayName/][if (spVal.specialType=SpecialType::MISSING)]MISSING:['['/][for (mv : ValueField | df.dataField.missingValues) separator(', ')][mv.value/][/for][']'/][elseif(spVal.specialType=SpecialType::INVALID)]INVALID:['['/][for (iv : ValueField | df.dataField.invalidValues) separator(', ')][iv.value/][/for][']'/][elseif(spVal.specialType=SpecialType::OUTLIER)]OUTLIERS[/if][/let][/for][/let][/if][/for] VALIDATED')
else:
	print('[aContract.oclAsType(Condition).conditionDef.type/] [aContract.eContainer(DataProcessing).origin_function/]([for (obj : Object | cond._in) separator(', ')][if (obj.oclIsKindOf(DataField))][let df : DataField = obj.oclAsType(DataField)][df.dataField.displayName/][/let][/if][/for]) FilterType:[if (cond.eContainer(DataProcessing).parameter->first().oclIsKindOf(FilterValue))][let fv : FilterValue = cond.eContainer(DataProcessing).parameter->first().oclAsType(FilterValue)][fv.filterType/][/let][/if] SpecialValues: [for (th2 : Then | cond._then) separator(', ')][if (th2.dataResult.oclIsKindOf(SpecialValue))][let spVal : SpecialValue = th2.dataResult.oclAsType(SpecialValue)][for (obj : Object | cond._in->select(odf | odf.oclIsTypeOf(DataField))) separator(', ')][let df : DataField = obj.oclAsType(DataField)][df.dataField.displayName/][if (spVal.specialType=SpecialType::MISSING)]MISSING:['['/][for (mv : ValueField | df.dataField.missingValues) separator(', ')][mv.value/][/for][']'/][elseif(spVal.specialType=SpecialType::INVALID)]INVALID:['['/][for (iv : ValueField | df.dataField.invalidValues) separator(', ')][iv.value/][/for][']'/][elseif(spVal.specialType=SpecialType::OUTLIER)]OUTLIERS[/if][/let][/for][/let][/if][/for] NOT VALIDATED')
				[/let]
			[/if]
		[/for]
	[/if]
[/let]								 																																	[comment CLOSE  assigns the contract to be of type Condition (Invariants)/]
[/template]


[template public joinOperands(operand : Operand)]
[if (operand.oclIsKindOf(OpField))][let field : OpField=operand.oclAsType(OpField)], '[field.datafield.dataField.displayName/]': True[/let][elseif (operand.oclIsKindOf(FixValue))][let fv : FixValue=operand.oclAsType(FixValue)], '[fv.value/]': False[/let][/if][if (operand.next_operand<>null)][joinOperands(operand.next_operand)/][/if]
[/template]


[template public generateCallConditionContractDataDictionary(cond : Contract, if_cond : If)]
[for (odd : Object | cond.out->select(odd | odd.oclIsTypeOf(DataDictionary)))]
	[let dd_out : DataDictionary = odd.oclAsType(DataDictionary)]
		[let th : Then = if_cond._then.oclAsType(Then)]																									[comment OPEN assigns the variable to be of type Then/]
			[for (dde : DataDictionaryElement | if_cond.dataCondition)]
				[if (dde.oclIsKindOf(RowValue))]
					[let v : RowValue = dde.oclAsType(RowValue)]
						[if (v.oclIsTypeOf(Interval))]
[comment]The code below generates the call to invariants of type MathOperation[/comment]
							[if (th.dataResult.oclIsTypeOf(MathOperation))]
								[let mathOp : MathOperation = th.dataResult.oclAsType(MathOperation)]
									[if (cond.out->exists(df | df.oclIsTypeOf(DataField)))]															[comment OPEN checks that the variable is of type DataField/]
if contract_invariants.check_inv_math_operation(data_dictionary_in=[dd_out.dataDictionary._in.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
						data_dictionary_out=[dd_out.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
						[if (mathOp.mathOp=MathOperator::SUM)]math_op=MathOperator(0)[elseif (mathOp.mathOp=MathOperator::SUBSTRACT)]math_op=MathOperator(1)[elseif (mathOp.mathOp=MathOperator::MULTIPLY)]math_op=MathOperator(2)[elseif (mathOp.mathOp=MathOperator::DIVIDE)]math_op=MathOperator(3)[/if],
						[for (operand : Operand | mathOp.operand)][if (operand.next_operand<>null)][if (operand.oclIsKindOf(OpField))][let fop : OpField = operand.oclAsType(OpField)]firstOperand='[fop.datafield.dataField.displayName/]', isFieldFirst=True, [/let][else][let fop : FixValue = operand.oclAsType(FixValue)]firstOperand=[fop.value/], isFieldFirst=False,[/let][/if][if (operand.next_operand.oclIsKindOf(OpField))][let sop : OpField = operand.next_operand.oclAsType(OpField)]secondOperand='[sop.datafield.dataField.displayName/]', isFieldSecond=True, [/let][else][let sop : FixValue = operand.next_operand.oclAsType(FixValue)]secondOperand=[sop.value/], isFieldSecond=False,[/let][/if][/if][/for]
						belong_op_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]), field_in=None, field_out=None, origin_function="[cond.eContainer(DataProcessing).origin_function/]"):
print('[cond.oclAsType(Condition).conditionDef.type/] [cond.eContainer(DataProcessing).origin_function/]([cond.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) [if (mathOp.mathOp=MathOperator::SUM)]sum([elseif (mathOp.mathOp=MathOperator::SUBSTRACT)]substract([elseif (mathOp.mathOp=MathOperator::MULTIPLY)]multiply([elseif (mathOp.mathOp=MathOperator::DIVIDE)]divide([/if][for (operand : Operand | mathOp.operand)][if (operand.next_operand<>null)][if (operand.oclIsKindOf(OpField))][let fop : OpField = operand.oclAsType(OpField)][fop.datafield.dataField.displayName/], [/let][else][let fop : FixValue = operand.oclAsType(FixValue)][fop.value/], [/let][/if][if (operand.next_operand.oclIsKindOf(OpField))][let sop : OpField = operand.next_operand.oclAsType(OpField)][sop.datafield.dataField.displayName/], [/let][else][let sop : FixValue = operand.next_operand.oclAsType(FixValue)][sop.value/], [/let][/if][/if][/for]) VALIDATED')
else:
	print('[cond.oclAsType(Condition).conditionDef.type/] [cond.eContainer(DataProcessing).origin_function/]([cond.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) [if (mathOp.mathOp=MathOperator::SUM)]sum([elseif (mathOp.mathOp=MathOperator::SUBSTRACT)]substract([elseif (mathOp.mathOp=MathOperator::MULTIPLY)]multiply([elseif (mathOp.mathOp=MathOperator::DIVIDE)]divide([/if][for (operand : Operand | mathOp.operand)][if (operand.next_operand<>null)][if (operand.oclIsKindOf(OpField))][let fop : OpField = operand.oclAsType(OpField)][fop.datafield.dataField.displayName/], [/let][else][let fop : FixValue = operand.oclAsType(FixValue)][fop.value/], [/let][/if][if (operand.next_operand.oclIsKindOf(OpField))][let sop : OpField = operand.next_operand.oclAsType(OpField)][sop.datafield.dataField.displayName/], [/let][else][let sop : FixValue = operand.next_operand.oclAsType(FixValue)][sop.value/], [/let][/if][/if][/for]) NOT VALIDATED')

									[/if]
								[/let]
							[/if]
						[/if]
					[/let]
				[/if]
			[/for]
			[if (if_cond.dataCondition->first().oclIsKindOf(Field))]
columns_list_[cond.name.replaceAll('[(),-/\\s]+', '_')/] = ['['/][for (dde : DataDictionaryElement | if_cond.dataCondition) separator (', ')][if (dde.oclIsKindOf(Field))][let field : Field = dde.oclAsType(Field)]'[field.dataField.displayName/]'[/let][/if][/for][']'/]
[comment]The code below generates the call to invariants of type filterColumns[/comment]

if contract_invariants.check_inv_filter_columns(data_dictionary_in=[dd_out.dataDictionary._in.name.replaceAll('[(),-/\\s]+', '_')/]_df,
						data_dictionary_out=[dd_out.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/]_df,
						columns=columns_list_[cond.name.replaceAll('[(),-/\\s]+', '_')/],
						belong_op=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]), origin_function="[cond.eContainer(DataProcessing).origin_function/]"):
	print('[cond.oclAsType(Condition).conditionDef.type/] [cond.eContainer(DataProcessing).origin_function/]([for (dde : DataDictionaryElement | if_cond.dataCondition) separator (', ')][if (dde.oclIsKindOf(Field))][let field : Field = dde.oclAsType(Field)][field.dataField.displayName/][/let][/if][/for]) VALIDATED')
else:
	print('[cond.oclAsType(Condition).conditionDef.type/] [cond.eContainer(DataProcessing).origin_function/]([for (dde : DataDictionaryElement | if_cond.dataCondition) separator (', ')][if (dde.oclIsKindOf(Field))][let field : Field = dde.oclAsType(Field)][field.dataField.displayName/][/let][/if][/for]) NOT VALIDATED')
			[/if]
		[/let]
	[/let]		
[/for]
[for (odd : Object | cond._in->select(odd | odd.oclIsTypeOf(DataDictionary)))]
	[let dd_in : DataDictionary = odd.oclAsType(DataDictionary)]																								[comment OPEN assigns the variable to be of type DataField/]
		[let th : Then = if_cond._then.oclAsType(Then)]																											[comment OPEN assigns the variable to be of type Then/]
			[for (dde : DataDictionaryElement | if_cond.dataCondition)]
				[if (dde.oclIsKindOf(RowValue))]
					[let v : RowValue = dde.oclAsType(RowValue)]
						[if (v.oclIsTypeOf(FixValue))]																													[comment OPEN checks that the type of the value is FixValue/]
							[let fv : FixValue = v.oclAsType(FixValue)]																									[comment OPEN assigns the variable to be of type FixValue/]
[comment]The code below generates the call to invariants of type FixValue-DerivedValue[/comment]
								[if (th.dataResult.oclIsTypeOf(DerivedValue))]																							[comment OPEN checks that the variable is of type DerivedValue/]
									[let derVal : DerivedValue = th.dataResult.oclAsType(DerivedValue)]																[comment OPEN assigns the variable to be of type DerivedValue/]
										[if (cond.out->exists(dd | dd.oclIsTypeOf(DataDictionary)))]																	[comment OPEN checks that the variable is of type DataField/]																	[comment OPEN checks that the variable is of type DataField/]
											[if (not dd_in.dataDictionary.datafield->isEmpty())]
if contract_invariants.check_inv_fix_value_derived_value(data_dictionary_in=[dd_in.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/]_df,
										data_dictionary_out=[dd_in.dataDictionary.datafield->first().out.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
										fix_value_input=[if (fv.dataType=DataType::String or fv.dataType=DataType::Time or fv.dataType=DataType::DateTime)]'[fv.value/]'[else][fv.value/][/if],
										belong_op_in=Belong([if (if_cond.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										belong_op_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										derived_type_output=DerivedType([if (derVal.type=DerivedType::MostFrequent)]0[elseif (derVal.type=DerivedType::Previous)]1[elseif (derVal.type=DerivedType::Next)]2[/if]),
										axis_param=0, field_in=None, field_out=None, origin_function="[cond.eContainer(DataProcessing).origin_function/]"):
	print('[cond.oclAsType(Condition).conditionDef.type/] [cond.eContainer(DataProcessing).origin_function/]([cond.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) FixValue:[fv.value/] To_[if (derVal.type=DerivedType::MostFrequent)]MostFrequent[elseif (derVal.type=DerivedType::Previous)]Previous[elseif (derVal.type=DerivedType::Next)]Next[/if] VALIDATED')
else:
	print('[cond.oclAsType(Condition).conditionDef.type/] [cond.eContainer(DataProcessing).origin_function/]([cond.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) FixValue:[fv.value/] To_[if (derVal.type=DerivedType::MostFrequent)]MostFrequent[elseif (derVal.type=DerivedType::Previous)]Previous[elseif (derVal.type=DerivedType::Next)]Next[/if] NOT VALIDATED')
											[elseif (dd_in.dataDictionary.datafield->isEmpty())]
raise Exception("It is not yet contemplated to have an invariant with data dictionaries as input and output and no datafields.")
											[/if]
										[/if]																															[comment CLOSE checks that the variable is of type DataDictionary or DataField/]
									[/let]																																[comment CLOSE assigns the variable to be of type DerivedValue/]
								[/if]																																	[comment CLOSE checks that the variable is of type DerivedValue/]
[comment]The code below generates the call to invariants of type FixValue-NumOp[/comment]
								[if (th.dataResult.oclIsTypeOf(NumOp))]																								[comment OPEN checks that the variable is of type NumOp/]
									[let nop : NumOp = th.dataResult.oclAsType(NumOp)]																					[comment OPEN assigns the variable to be of type NumOp/]
										[if (cond.out->exists(dd | dd.oclIsTypeOf(DataDictionary)))]																	[comment OPEN checks that the variable is of type DataField/]																	[comment OPEN checks that the variable is of type DataField/]
											[if (not dd_in.dataDictionary.datafield->isEmpty())]
if contract_invariants.check_inv_fix_value_num_op(data_dictionary_in=[dd_in.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/]_df,
										data_dictionary_out=[dd_in.dataDictionary.datafield->first().out.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
										fix_value_input=[if (fv.dataType=DataType::String or fv.dataType=DataType::Time or fv.dataType=DataType::DateTime)]'[fv.value/]'[else][fv.value/][/if],
										belong_op_in=Belong([if (if_cond.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										belong_op_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										num_op_output=Operation([if (nop.operation=Operation::Interpolation)]0[elseif (nop.operation=Operation::Mean)]1[elseif (nop.operation=Operation::Median)]2[elseif (nop.operation=Operation::Closest)]3[/if]),
										axis_param=0, field_in=None, field_out=None, origin_function="[cond.eContainer(DataProcessing).origin_function/]"):
	print('[cond.oclAsType(Condition).conditionDef.type/] [cond.eContainer(DataProcessing).origin_function/]([cond.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) FixValue:[fv.value/] To_[if (nop.operation=Operation::Interpolation)]Interpolation[elseif (nop.operation=Operation::Mean)]Mean[elseif (nop.operation=Operation::Median)]Median[elseif (nop.operation=Operation::Closest)]Closest[/if] VALIDATED')
else:
	print('[cond.oclAsType(Condition).conditionDef.type/] [cond.eContainer(DataProcessing).origin_function/]([cond.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) FixValue:[fv.value/] To_[if (nop.operation=Operation::Interpolation)]Interpolation[elseif (nop.operation=Operation::Mean)]Mean[elseif (nop.operation=Operation::Median)]Median[elseif (nop.operation=Operation::Closest)]Closest[/if] NOT VALIDATED')
											[elseif (dd_in.dataDictionary.datafield->isEmpty())]
raise Exception("It is not yet contemplated to have an invariant with data dictionaries as input and output and no datafields.")
											[/if]
										[/if]																															[comment CLOSE checks that the variable is of type DataDictionary or DataField/]
									[/let]																																[comment CLOSE assigns the variable to be of type NumOp/]
								[/if]																																	[comment CLOSE checks that the variable is of type NumOp/]
							[/let]																																		[comment CLOSE assigns the variable to be of type FixValue/]
						[/if]																																			[comment CLOSE checks that the type of the value is FixValue/]
						[if (v.oclIsTypeOf(Interval))]																													[comment OPEN checks that the type of the value is Interval/]
							[let int : Interval = v.oclAsType(Interval)]																								[comment OPEN assigns the variable to be of type Interval/]
[comment]The code below generates the call to invariants of type Interval-FixValue[/comment]
								[if (th.dataResult.oclIsTypeOf(FixValue))]																								[comment OPEN checks that the variable is of type FixValue/]
									[let fvt : FixValue = th.dataResult.oclAsType(FixValue)]																			[comment OPEN assigns the variable to be of type FixValue/]																											[comment CLOSE assigns the variable to be of type DataDictionary/]
										[if (cond.out->exists(dd | dd.oclIsTypeOf(DataDictionary)))]																	[comment OPEN checks that the variable is of type DataField/]																	[comment OPEN checks that the variable is of type DataField/]
											[if (not dd_in.dataDictionary.datafield->isEmpty())]
if contract_invariants.check_inv_interval_fix_value(data_dictionary_in=[dd_in.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/]_df,
										data_dictionary_out=[dd_in.dataDictionary.datafield->first().out.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
										left_margin=[int.leftMargin/], right_margin=[int.rightMargin/],
										closure_type=Closure([if (int.closureType=ClosureType::openOpen)]0[elseif (int.closureType=ClosureType::openClosed)]1[elseif (int.closureType=ClosureType::closedOpen)]2[elseif (int.closureType=ClosureType::closedClosed)]3[/if]),
										fix_value_output=[if (fvt.dataType=DataType::String or fvt.dataType=DataType::Time or fvt.dataType=DataType::DateTime)]'[fvt.value/]'[else][fvt.value/][/if],
										belong_op_in=Belong([if (if_cond.belongOp=BelongOp::BELONG)]0[else]1[/if]), belong_op_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										data_type_output=[if (fvt.dataType=DataType::String)]DataType(0)[elseif (fvt.dataType=DataType::Time)]DataType(1)[elseif (fvt.dataType=DataType::Integer)]DataType(2)[elseif (fvt.dataType=DataType::DateTime)]DataType(3)[elseif (fvt.dataType=DataType::Boolean)]DataType(4)[elseif (fvt.dataType=DataType::Double)]DataType(5)[elseif (fvt.dataType=DataType::Float)]DataType(6)[else]None)[/if],
										field_in=None, field_out=None, origin_function="[cond.eContainer(DataProcessing).origin_function/]"):
	print('[cond.oclAsType(Condition).conditionDef.type/] [cond.eContainer(DataProcessing).origin_function/]([cond.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) Interval:[if (int.closureType=ClosureType::openOpen or int.closureType=ClosureType::openClosed)]([elseif (int.closureType=ClosureType::closedOpen or int.closureType=ClosureType::closedClosed)]['['/][/if][int.leftMargin/], [int.rightMargin/][if (int.closureType=ClosureType::openOpen or int.closureType=ClosureType::closedOpen)])[elseif (int.closureType=ClosureType::openClosed or int.closureType=ClosureType::closedClosed)][']'/][/if] FixValue:[fvt.value/] VALIDATED')
else:
	print('[cond.oclAsType(Condition).conditionDef.type/] [cond.eContainer(DataProcessing).origin_function/]([cond.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) Interval:[if (int.closureType=ClosureType::openOpen or int.closureType=ClosureType::openClosed)]([elseif (int.closureType=ClosureType::closedOpen or int.closureType=ClosureType::closedClosed)]['['/][/if][int.leftMargin/], [int.rightMargin/][if (int.closureType=ClosureType::openOpen or int.closureType=ClosureType::closedOpen)])[elseif (int.closureType=ClosureType::openClosed or int.closureType=ClosureType::closedClosed)][']'/][/if] FixValue:[fvt.value/] NOT VALIDATED')
											[elseif (dd_in.dataDictionary.datafield->isEmpty())]
raise Exception("It is not yet contemplated to have an invariant with data dictionaries as input and output and no datafields.")
											[/if]
										[/if]																															[comment CLOSE checks that the output is DataDictionary or DataField/]
									[/let]																																[comment CLOSE assigns the variable to be of type FixValue/]
								[/if]																																	[comment CLOSE checks that the variable is of type FixValue/]
[comment]The code below generates the call to invariants of type Interval-DerivedValue[/comment]
								[if (th.dataResult.oclIsTypeOf(DerivedValue))]																							[comment OPEN checks that the variable is of type DerivedValue/]
									[let derVal : DerivedValue = th.dataResult.oclAsType(DerivedValue)]																[comment OPEN assigns the variable to be of type DerivedValue/]
										[if (cond.out->exists(dd | dd.oclIsTypeOf(DataDictionary)))]																	[comment OPEN checks that the variable is of type DataField/]																	[comment OPEN checks that the variable is of type DataField/]
											[if (not dd_in.dataDictionary.datafield->isEmpty())]
if contract_invariants.check_inv_interval_derived_value(data_dictionary_in=[dd_in.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/]_df,
										data_dictionary_out=[dd_in.dataDictionary.datafield->first().out.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
										left_margin=[int.leftMargin/], right_margin=[int.rightMargin/],
										closure_type=Closure([if (int.closureType=ClosureType::openOpen)]0[elseif (int.closureType=ClosureType::openClosed)]1[elseif (int.closureType=ClosureType::closedOpen)]2[elseif (int.closureType=ClosureType::closedClosed)]3[/if]),
										belong_op_in=Belong([if (if_cond.belongOp=BelongOp::BELONG)]0[else]1[/if]), belong_op_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										derived_type_output=DerivedType([if (derVal.type=DerivedType::MostFrequent)]0[elseif (derVal.type=DerivedType::Previous)]1[elseif (derVal.type=DerivedType::Next)]2[/if]),
										axis_param=0, field_in=None, field_out=None, origin_function="[cond.eContainer(DataProcessing).origin_function/]"):
	print('[cond.oclAsType(Condition).conditionDef.type/] [cond.eContainer(DataProcessing).origin_function/]([cond.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) Interval:[if (int.closureType=ClosureType::openOpen or int.closureType=ClosureType::openClosed)]([elseif (int.closureType=ClosureType::closedOpen or int.closureType=ClosureType::closedClosed)]['['/][/if][int.leftMargin/], [int.rightMargin/][if (int.closureType=ClosureType::openOpen or int.closureType=ClosureType::closedOpen)])[elseif (int.closureType=ClosureType::openClosed or int.closureType=ClosureType::closedClosed)][']'/][/if] To_[if (derVal.type=DerivedType::MostFrequent)]MostFrequent[elseif (derVal.type=DerivedType::Previous)]Previous[elseif (derVal.type=DerivedType::Next)]Next[/if] VALIDATED')
else:
	print('[cond.oclAsType(Condition).conditionDef.type/] [cond.eContainer(DataProcessing).origin_function/]([cond.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) Interval:[if (int.closureType=ClosureType::openOpen or int.closureType=ClosureType::openClosed)]([elseif (int.closureType=ClosureType::closedOpen or int.closureType=ClosureType::closedClosed)]['['/][/if][int.leftMargin/], [int.rightMargin/][if (int.closureType=ClosureType::openOpen or int.closureType=ClosureType::closedOpen)])[elseif (int.closureType=ClosureType::openClosed or int.closureType=ClosureType::closedClosed)][']'/][/if] To_[if (derVal.type=DerivedType::MostFrequent)]MostFrequent[elseif (derVal.type=DerivedType::Previous)]Previous[elseif (derVal.type=DerivedType::Next)]Next[/if] NOT VALIDATED')
											[elseif (dd_in.dataDictionary.datafield->isEmpty())]
raise Exception("It is not yet contemplated to have an invariant with data dictionaries as input and output and no datafields.")
											[/if]
										[/if]																															[comment CLOSE checks that the output is DataDictionary or DataField/]
									[/let]																																[comment CLOSE assigns the variable to be of type DerivedValue/]
								[/if]																																	[comment CLOSE checks that the variable is of type derivedValue/]
[comment]The code below generates the call to invariants of type Interval-NumOp[/comment]
								[if (th.dataResult.oclIsTypeOf(NumOp))]																								[comment OPEN checks that the variable is of type NumOp/]
									[let nop : NumOp = th.dataResult.oclAsType(NumOp)]																					[comment OPEN assigns the variable to be of type NumOp/]
										[if (cond.out->exists(dd | dd.oclIsTypeOf(DataDictionary)))]																	[comment OPEN checks that the variable is of type DataField/]																	[comment OPEN checks that the variable is of type DataField/]
											[if (not dd_in.dataDictionary.datafield->isEmpty())]
if contract_invariants.check_inv_interval_num_op(data_dictionary_in=[dd_in.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/]_df,
										data_dictionary_out=[dd_in.dataDictionary.datafield->first().out.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
										left_margin=[int.leftMargin/], right_margin=[int.rightMargin/],
										closure_type=Closure([if (int.closureType=ClosureType::openOpen)]0[elseif (int.closureType=ClosureType::openClosed)]1[elseif (int.closureType=ClosureType::closedOpen)]2[elseif (int.closureType=ClosureType::closedClosed)]3[/if]),
										belong_op_in=Belong([if (if_cond.belongOp=BelongOp::BELONG)]0[else]1[/if]), belong_op_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										num_op_output=Operation([if (nop.operation=Operation::Interpolation)]0[elseif (nop.operation=Operation::Mean)]1[elseif (nop.operation=Operation::Median)]2[elseif (nop.operation=Operation::Closest)]3[/if]),
										axis_param=0, field_in=None, field_out=None, origin_function="[cond.eContainer(DataProcessing).origin_function/]"):
	print('[cond.oclAsType(Condition).conditionDef.type/] [cond.eContainer(DataProcessing).origin_function/]([cond.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) Interval:[if (int.closureType=ClosureType::openOpen or int.closureType=ClosureType::openClosed)]([elseif (int.closureType=ClosureType::closedOpen or int.closureType=ClosureType::closedClosed)]['['/][/if][int.leftMargin/], [int.rightMargin/][if (int.closureType=ClosureType::openOpen or int.closureType=ClosureType::closedOpen)])[elseif (int.closureType=ClosureType::openClosed or int.closureType=ClosureType::closedClosed)][']'/][/if] To_[if (nop.operation=Operation::Interpolation)]Interpolation[elseif (nop.operation=Operation::Mean)]Mean[elseif (nop.operation=Operation::Median)]Median[elseif (nop.operation=Operation::Closest)]Closest[/if] VALIDATED')
else:
	print('[cond.oclAsType(Condition).conditionDef.type/] [cond.eContainer(DataProcessing).origin_function/]([cond.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) Interval:[if (int.closureType=ClosureType::openOpen or int.closureType=ClosureType::openClosed)]([elseif (int.closureType=ClosureType::closedOpen or int.closureType=ClosureType::closedClosed)]['['/][/if][int.leftMargin/], [int.rightMargin/][if (int.closureType=ClosureType::openOpen or int.closureType=ClosureType::closedOpen)])[elseif (int.closureType=ClosureType::openClosed or int.closureType=ClosureType::closedClosed)][']'/][/if] To_[if (nop.operation=Operation::Interpolation)]Interpolation[elseif (nop.operation=Operation::Mean)]Mean[elseif (nop.operation=Operation::Median)]Median[elseif (nop.operation=Operation::Closest)]Closest[/if] NOT VALIDATED')
											[elseif (dd_in.dataDictionary.datafield->isEmpty())]
raise Exception("It is not yet contemplated to have an invariant with data dictionaries as input and output and no datafields.")
											[/if]
										[/if]																															[comment CLOSE checks that the output is DataDictionary or DataField/]
									[/let]																																[comment CLOSE assigns the variable to be of type NumOp/]
								[/if]																																	[comment CLOSE checks that the variable is of type NumOp/]
							[/let]																																		[comment CLOSE assigns the variable to be of type Interval/]
						[/if]																																			[comment CLOSE checks that the type of the value is Interval/]
						[if (v.oclIsTypeOf(SpecialValue))]																												[comment OPEN checks that the type of the value is SpecialValue/]
							[let sv : SpecialValue = v.oclAsType(SpecialValue)]																							[comment OPEN assigns the variable to be of type SpecialValue/]
[comment]The code below generates the call to invariants of type SpecialValue-FixValue[/comment]
								[if (th.dataResult.oclIsTypeOf(FixValue))]																								[comment OPEN checks that the type of the result is FixValue/]
									[let fixVal : FixValue = th.dataResult.oclAsType(FixValue)]																		[comment OPEN assigns the variable to be of type FixValue/]
										[if(cond.out->exists(dd | dd.oclIsTypeOf(DataDictionary)))]																		[comment OPEN checks that the output is a DataField/]
											[if (not dd_in.dataDictionary.datafield->isEmpty())]
if contract_invariants.check_inv_special_value_fix_value(data_dictionary_in=[dd_in.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/]_df,
							data_dictionary_out=[dd_in.dataDictionary.datafield->first().out.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
							special_type_input=SpecialType([if (sv.specialType=SpecialType::MISSING)]0[elseif (sv.specialType=SpecialType::INVALID)]1[elseif (sv.specialType=SpecialType::OUTLIER)]2[/if]),
							fix_value_output=[if (fixVal.dataType=DataType::String or fixVal.dataType=DataType::Time or fixVal.dataType=DataType::DateTime)]'[fixVal.value/]'[else][fixVal.value/][/if],
							belong_op_in=Belong([if (if_cond.belongOp=BelongOp::BELONG)]0[else]1[/if]),
							belong_op_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]),
							data_type_output=[if (fixVal.dataType=DataType::String)]DataType(0)[elseif (fixVal.dataType=DataType::Time)]DataType(1)[elseif (fixVal.dataType=DataType::Integer)]DataType(2)[elseif (fixVal.dataType=DataType::DateTime)]DataType(3)[elseif (fixVal.dataType=DataType::Boolean)]DataType(4)[elseif (fixVal.dataType=DataType::Double)]DataType(5)[elseif (fixVal.dataType=DataType::Float)]DataType(6)[else]None)[/if],
							missing_values=None, axis_param=0, field_in=None, field_out=None, origin_function="[cond.eContainer(DataProcessing).origin_function/]"):
	print('[cond.oclAsType(Condition).conditionDef.type/] [cond.eContainer(DataProcessing).origin_function/]([cond.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) [if (sv.specialType=SpecialType::MISSING)]MISSING[elseif (sv.specialType=SpecialType::INVALID)]INVALID[elseif (sv.specialType=SpecialType::OUTLIER)]OUTLIER[/if]_FixValue:[fixVal.value/] VALIDATED')
else:
	print('[cond.oclAsType(Condition).conditionDef.type/] [cond.eContainer(DataProcessing).origin_function/]([cond.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) [if (sv.specialType=SpecialType::MISSING)]MISSING[elseif (sv.specialType=SpecialType::INVALID)]INVALID[elseif (sv.specialType=SpecialType::OUTLIER)]OUTLIER[/if]_FixValue:[fixVal.value/] NOT VALIDATED')
											[elseif (dd_in.dataDictionary.datafield->isEmpty())]
raise Exception("It is not yet contemplated to have an invariant with data dictionaries as input and output and no datafields.")
											[/if]
										[/if]																															[comment CLOSE checks that the output is a DataDictionary or a DataField/]
									[/let]																																[comment CLOSE assigns the variable to be of type FixValue/]
								[/if]																																	[comment CLOSE checks that the type of the result is FixValue/]
[comment]The code below generates the call to invariants of type SpecialValue-DerivedValue[/comment]
								[if (th.dataResult.oclIsTypeOf(DerivedValue))]																							[comment OPEN checks that the type of the result is DerivedValue/]
									[let derVal : DerivedValue = th.dataResult.oclAsType(DerivedValue)]																[comment OPEN assigns the variable to be of type DerivedValue/]
										[if(cond.out->exists(dd | dd.oclIsTypeOf(DataDictionary)))]																		[comment OPEN checks that the output is a DataField/]
											[if (not dd_in.dataDictionary.datafield->isEmpty())]
if contract_invariants.check_inv_special_value_derived_value(data_dictionary_in=[dd_in.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/]_df,
							data_dictionary_out=[dd_in.dataDictionary.datafield->first().out.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
							belong_op_in=Belong([if (if_cond.belongOp=BelongOp::BELONG)]0[else]1[/if]),
							belong_op_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]),
							special_type_input=SpecialType([if (sv.specialType=SpecialType::MISSING)]0[elseif (sv.specialType=SpecialType::INVALID)]1[elseif (sv.specialType=SpecialType::OUTLIER)]2[/if]),
							derived_type_output=DerivedType([if (derVal.type=DerivedType::MostFrequent)]0[elseif (derVal.type=DerivedType::Previous)]1[elseif (derVal.type=DerivedType::Next)]2[/if]),
							missing_values=None, axis_param=0, field_in=None, field_out=None, origin_function="[cond.eContainer(DataProcessing).origin_function/]"):
	print('[cond.oclAsType(Condition).conditionDef.type/] [cond.eContainer(DataProcessing).origin_function/]([cond.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) [if (sv.specialType=SpecialType::MISSING)]MISSING[elseif (sv.specialType=SpecialType::INVALID)]INVALID[elseif (sv.specialType=SpecialType::OUTLIER)]OUTLIER[/if]_to_[if (derVal.type=DerivedType::MostFrequent)]MostFrequent[elseif (derVal.type=DerivedType::Previous)]Previous[elseif (derVal.type=DerivedType::Next)]Next[/if] VALIDATED')
else:
	print('[cond.oclAsType(Condition).conditionDef.type/] [cond.eContainer(DataProcessing).origin_function/]([cond.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) [if (sv.specialType=SpecialType::MISSING)]MISSING[elseif (sv.specialType=SpecialType::INVALID)]INVALID[elseif (sv.specialType=SpecialType::OUTLIER)]OUTLIER[/if]_to_[if (derVal.type=DerivedType::MostFrequent)]MostFrequent[elseif (derVal.type=DerivedType::Previous)]Previous[elseif (derVal.type=DerivedType::Next)]Next[/if] NOT VALIDATED')
											[elseif (dd_in.dataDictionary.datafield->isEmpty())]
raise Exception("It is not yet contemplated to have an invariant with data dictionaries as input and output and no datafields.")
											[/if]
										[/if]																															[comment CLOSE checks that the output is a DataField/]
									[/let]																																[comment CLOSE assigns the variable to be of type DerivedValue/]
								[/if]																																	[comment CLOSE checks that the type of the result is DerivedValue/]
[comment]The code below generates the call to invariants of type SpecialValue-NumOp[/comment]	
								[if (th.dataResult.oclIsTypeOf(NumOp))]																								[comment OPEN checks that the type of the result is NumOp/]
									[let nop : NumOp = th.dataResult.oclAsType(NumOp)]																					[comment OPEN assigns the variable to be of type NumOp/]																													[comment CLOSE checks that SpecialType is MISSING or INVALID/]
										[if(cond.out->exists(dd | dd.oclIsTypeOf(DataDictionary)))]																		[comment OPEN checks that the output is a DataField/]
											[if (not dd_in.dataDictionary.datafield->isEmpty())]
if contract_invariants.check_inv_special_value_num_op(data_dictionary_in=[dd_in.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/]_df,
										data_dictionary_out=[dd_in.dataDictionary.datafield->first().out.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
										belong_op_in=Belong([if (if_cond.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										belong_op_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										special_type_input=SpecialType([if (sv.specialType=SpecialType::MISSING)]0[elseif (sv.specialType=SpecialType::INVALID)]1[elseif (sv.specialType=SpecialType::OUTLIER)]2[/if]),
										num_op_output=Operation([if (nop.operation=Operation::Interpolation)]0[elseif (nop.operation=Operation::Mean)]1[elseif (nop.operation=Operation::Median)]2[elseif (nop.operation=Operation::Closest)]3[/if]),
										missing_values=None, axis_param=0, field_in=None, field_out=None, origin_function="[cond.eContainer(DataProcessing).origin_function/]"):
	print('[cond.oclAsType(Condition).conditionDef.type/] [cond.eContainer(DataProcessing).origin_function/]([cond.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) [if (sv.specialType=SpecialType::MISSING)]MISSING[elseif (sv.specialType=SpecialType::INVALID)]INVALID[elseif (sv.specialType=SpecialType::OUTLIER)]OUTLIER[/if]_to_[if (nop.operation=Operation::Interpolation)]Interpolation[elseif (nop.operation=Operation::Mean)]Mean[elseif (nop.operation=Operation::Median)]Median[elseif (nop.operation=Operation::Closest)]Closest[/if] VALIDATED')
else:
	print('[cond.oclAsType(Condition).conditionDef.type/] [cond.eContainer(DataProcessing).origin_function/]([cond.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) [if (sv.specialType=SpecialType::MISSING)]MISSING[elseif (sv.specialType=SpecialType::INVALID)]INVALID[elseif (sv.specialType=SpecialType::OUTLIER)]OUTLIER[/if]_to_[if (nop.operation=Operation::Interpolation)]Interpolation[elseif (nop.operation=Operation::Mean)]Mean[elseif (nop.operation=Operation::Median)]Median[elseif (nop.operation=Operation::Closest)]Closest[/if] NOT VALIDATED')
											[elseif (dd_in.dataDictionary.datafield->isEmpty())]
raise Exception("It is not yet contemplated to have an invariant with data dictionaries as input and output and no datafields.")
											[/if]
										[/if]																															[comment CLOSE checks that the output is a DataDictionary or a DataField/]
									[/let]																																[comment CLOSE assigns the variable to be of type NumOp/]
								[/if]																																	[comment CLOSE checks that the type of the result is NumOp/]
							[/let]																																		[comment CLOSE assigns the variable to be of type SpecialValue/]
						[/if]																																			[comment CLOSE checks that the type of the value is FixValue or SpecialValue (if at the beginning)/]
						[if (v.oclIsTypeOf(CastType))]
							[let ctif : CastType = v.oclAsType(CastType)]																							[comment OPEN assigns the variable to be of type SpecialValue/]
[comment]The code below generates the call to invariants of type CastType-CastType[/comment]
								[if (th.dataResult.oclIsTypeOf(CastType))]																						
									[let ctthen : CastType = th.dataResult.oclAsType(CastType)]
										[if(cond.out->exists(df | df.oclIsTypeOf(DataField)))]																[comment OPEN checks that the output is a DataField/]
if contract_invariants.check_inv_cast_type(data_dictionary_in=[dd_in.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/]_df,
										data_dictionary_out=[dd_in.dataDictionary.datafield->first().out.eContainer(Workflow::DataDictionary).name.replaceAll('[(),-/\\s]+', '_')/]_df,
							cast_type_in=[if (ctif.type=DataType::String)]DataType(0)[elseif (ctif.type=DataType::Time)]DataType(1)[elseif (ctif.type=DataType::Integer)]DataType(2)[elseif (ctif.type=DataType::DateTime)]DataType(3)[elseif (ctif.type=DataType::Boolean)]DataType(4)[elseif (ctif.type=DataType::Double)]DataType(5)[elseif (ctif.type=DataType::Float)]DataType(6)[else]None)[/if],
							cast_type_out=[if (ctthen.type=DataType::String)]DataType(0)[elseif (ctthen.type=DataType::Time)]DataType(1)[elseif (ctthen.type=DataType::Integer)]DataType(2)[elseif (ctthen.type=DataType::DateTime)]DataType(3)[elseif (ctthen.type=DataType::Boolean)]DataType(4)[elseif (ctthen.type=DataType::Double)]DataType(5)[elseif (ctthen.type=DataType::Float)]DataType(6)[else]None)[/if],
							belong_op_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]),
							field_in=None, field_out=None, origin_function="[cond.eContainer(DataProcessing).origin_function/]")
	print('[cond.oclAsType(Condition).conditionDef.type/] [cond.eContainer(DataProcessing).origin_function/]([cond.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) [if (ctif.type=DataType::String)]String[elseif (ctif.type=DataType::Time)]Time[elseif (ctif.type=DataType::Integer)]Integer[elseif (ctif.type=DataType::DateTime)]DateTime[elseif (ctif.type=DataType::Boolean)]Boolean[elseif (ctif.type=DataType::Double)]Double[elseif (ctif.type=DataType::Float)]Float[else]None)[/if]_to_[if (ctthen.type=DataType::String)]String[elseif (ctthen.type=DataType::Time)]Time[elseif (ctthen.type=DataType::Integer)]Integer[elseif (ctthen.type=DataType::DateTime)]DateTime[elseif (ctthen.type=DataType::Boolean)]Boolean[elseif (ctthen.type=DataType::Double)]Double[elseif (ctthen.type=DataType::Float)]Float[else]None)[/if] VALIDATED')
else:
	print('[cond.oclAsType(Condition).conditionDef.type/] [cond.eContainer(DataProcessing).origin_function/]([cond.eContainer(DataProcessing).eContainer(Workflow).environment.path/]) [if (ctif.type=DataType::String)]String[elseif (ctif.type=DataType::Time)]Time[elseif (ctif.type=DataType::Integer)]Integer[elseif (ctif.type=DataType::DateTime)]DateTime[elseif (ctif.type=DataType::Boolean)]Boolean[elseif (ctif.type=DataType::Double)]Double[elseif (ctif.type=DataType::Float)]Float[else]None)[/if]_to_[if (ctthen.type=DataType::String)]String[elseif (ctthen.type=DataType::Time)]Time[elseif (ctthen.type=DataType::Integer)]Integer[elseif (ctthen.type=DataType::DateTime)]DateTime[elseif (ctthen.type=DataType::Boolean)]Boolean[elseif (ctthen.type=DataType::Double)]Double[elseif (ctthen.type=DataType::Float)]Float[else]None)[/if] NOT VALIDATED')
										[/if]
									[/let]
								[/if]
							[/let]
						[/if]
					[/let]
				[/if]
			[/for]																																				[comment CLOSE traverse all the values associated to the contract/]
		[/let]																																					[comment CLOSE assigns the variable to be of type Then/]
	[/let]																																						[comment CLOSE assigns the variable to be of type DataField/]
[/for]
[/template]






